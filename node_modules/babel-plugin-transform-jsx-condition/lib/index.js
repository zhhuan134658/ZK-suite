"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var directiveIf = 'x-if';
var directiveElseif = 'x-elseif';
var directiveElse = 'x-else';
var helperImportedFrom = 'babel-runtime-jsx-plus';
var helperImportedName = 'createCondition';
var helperLocalName = '__create_condition__';

function _default(_ref) {
  var t = _ref.types;

  /**
   * Get condition type, enum of {if|elseif|else|null}
   */
  function getCondition(jsxElement) {
    if (t.isJSXOpeningElement(jsxElement.openingElement)) {
      var attributes = jsxElement.openingElement.attributes;

      for (var i = 0, l = attributes.length; i < l; i++) {
        if (t.isJSXAttribute(attributes[i])) {
          switch (attributes[i].name.name) {
            case directiveIf:
            case directiveElseif:
            case directiveElse:
              return {
                type: attributes[i].name.name,
                value: t.isJSXExpressionContainer(attributes[i].value) ? attributes[i].value.expression : attributes[i].value,
                index: i
              };
          }
        }
      }
    }

    return null;
  }

  return {
    visitor: {
      Program: function Program(path) {
        path.__conditionHelperImported = false;
      },
      JSXElement: function JSXElement(path) {
        var node = path.node,
            parentPath = path.parentPath;
        var condition = getCondition(node);

        if (condition !== null && condition.value !== null && condition.type === directiveIf) {
          var type = condition.type,
              value = condition.value,
              index = condition.index;
          var conditions = [];
          node.openingElement.attributes.splice(index, 1);
          conditions.push({
            condition: value,
            jsxElement: node
          });
          var continueSearch = false;
          var nextJSXElPath = path;
          var nextJSXElCondition;

          do {
            nextJSXElPath = nextJSXElPath.getSibling(nextJSXElPath.key + 1);

            if (nextJSXElPath.isJSXText() && nextJSXElPath.node.value.trim() === '') {
              continueSearch = true;
            } else if (nextJSXElPath.isJSXElement() && (nextJSXElCondition = getCondition(nextJSXElPath.node)) && nextJSXElCondition.type !== directiveIf) {
              conditions.push({
                condition: nextJSXElCondition.type === directiveElseif ? nextJSXElCondition.value : t.booleanLiteral(true),
                jsxElement: nextJSXElPath.node
              });
              nextJSXElPath.node.openingElement.attributes.splice(nextJSXElCondition.index, 1);
              nextJSXElPath.remove();
              continueSearch = nextJSXElCondition.type === directiveElseif;
            } else {
              continueSearch = false;
            }
          } while (continueSearch);

          var arrayExp = t.arrayExpression(conditions.map(function (_ref2) {
            var condition = _ref2.condition,
                jsxElement = _ref2.jsxElement;
            var elements = [t.arrowFunctionExpression([], condition), t.arrowFunctionExpression([], jsxElement)];
            return t.arrayExpression(elements);
          }));
          var callExp = t.callExpression(t.identifier(helperLocalName), [arrayExp]);

          if (parentPath.isJSXElement()) {
            path.replaceWith(t.jsxExpressionContainer(callExp));
          } else {
            path.replaceWith(callExp);
          }

          var rootPath = path.findParent(function (p) {
            return p.isProgram();
          });

          if (rootPath.__conditionHelperImported === false) {
            var imported = t.identifier(helperImportedName);
            var local = t.identifier(helperLocalName);
            var importDeclaration = t.importDeclaration([t.importSpecifier(local, imported)], t.stringLiteral(helperImportedFrom));
            rootPath.unshiftContainer('body', importDeclaration);
            rootPath.__conditionHelperImported = true;
          }
        }
      }
    }
  };
}