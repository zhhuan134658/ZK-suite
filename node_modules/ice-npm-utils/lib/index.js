"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageLocalVersion = exports.readPackageJSON = exports.packageJSONFilename = exports.getAndExtractTarball = exports.getNpmTarball = exports.checkAliInternal = exports.getNpmInfo = exports.isAliNpm = exports.getSatisfiesVersions = exports.getVersions = exports.getNpmClient = exports.getUnpkgHost = exports.getNpmRegistry = exports.getNpmLatestSemverVersion = exports.getLatestVersion = void 0;
const path = require("path");
const mkdirp = require("mkdirp");
const semver = require("semver");
const zlib = require("zlib");
const tar = require("tar");
const fse = require("fs-extra");
const constant_1 = require("@appworks/constant");
const axios_1 = require("axios");
const urlJoin = require("url-join");
/**
 * 获取指定 npm 包版本的 tarball
 */
function getNpmTarball(npm, version, registry) {
    return getNpmInfo(npm, registry).then((json) => {
        if (!semver.valid(version)) {
            // support beta or other tag
            version = json['dist-tags'][version] || json['dist-tags'].latest;
        }
        if (semver.valid(version) && json.versions && json.versions[version] && json.versions[version].dist) {
            return json.versions[version].dist.tarball;
        }
        return Promise.reject(new Error(`没有在 ${registry} 源上找到 ${npm}@${version} 包`));
    });
}
exports.getNpmTarball = getNpmTarball;
/**
 * 获取 tar 并将其解压到指定的文件夹
 */
function getAndExtractTarball(destDir, tarball, 
// eslint-disable-next-line
progressFunc = (state) => { }, formatFilename = (filename) => {
    // 为了兼容
    if (filename === '_package.json') {
        return filename.replace(/^_/, '');
    }
    else {
        return filename.replace(/^_/, '.');
    }
}) {
    return new Promise((resolve, reject) => {
        const allFiles = [];
        const allWriteStream = [];
        const dirCollector = [];
        axios_1.default({
            url: tarball,
            timeout: 10000,
            responseType: 'stream',
            onDownloadProgress: (progressEvent) => {
                progressFunc(progressEvent);
            },
        }).then((response) => {
            const totalLength = Number(response.headers['content-length']);
            let downloadLength = 0;
            response.data
                // @ts-ignore
                .on('data', (chunk) => {
                downloadLength += chunk.length;
                progressFunc({
                    percent: (downloadLength - 50) / totalLength,
                });
            })
                // @ts-ignore
                .pipe(zlib.Unzip())
                // @ts-ignore
                .pipe(new tar.Parse())
                .on('entry', (entry) => {
                if (entry.type === 'Directory') {
                    entry.resume();
                    return;
                }
                const realPath = entry.path.replace(/^package\//, '');
                let filename = path.basename(realPath);
                filename = formatFilename(filename);
                const destPath = path.join(destDir, path.dirname(realPath), filename);
                const dirToBeCreate = path.dirname(destPath);
                if (!dirCollector.includes(dirToBeCreate)) {
                    dirCollector.push(dirToBeCreate);
                    mkdirp.sync(dirToBeCreate);
                }
                allFiles.push(destPath);
                allWriteStream.push(new Promise((streamResolve) => {
                    entry
                        .pipe(fse.createWriteStream(destPath))
                        .on('finish', () => streamResolve())
                        .on('close', () => streamResolve()); // resolve when file is empty in node v8
                }));
            })
                .on('end', () => {
                if (progressFunc) {
                    progressFunc({
                        percent: 1,
                    });
                }
                Promise.all(allWriteStream)
                    .then(() => resolve(allFiles))
                    .catch(reject);
            });
        });
    });
}
exports.getAndExtractTarball = getAndExtractTarball;
/**
 * 从 registry 获取 npm 的信息
 */
function getNpmInfo(npm, registry) {
    const register = registry || getNpmRegistry(npm);
    const url = urlJoin(register, npm);
    return axios_1.default({ url }).then((response) => {
        return response.data;
    });
}
exports.getNpmInfo = getNpmInfo;
/**
 * 获取某个 npm 的所有版本号
 */
function getVersions(npm, registry) {
    return getNpmInfo(npm, registry).then((body) => {
        const versions = Object.keys(body.versions);
        return versions;
    });
}
exports.getVersions = getVersions;
/**
 * 根据指定范围（比如：1.x，< 5.x），获取符合的所有版本号
 */
function getSatisfiesVersions(npm, range, registry) {
    return getVersions(npm, registry).then((versions) => {
        return versions
            .filter((version) => semver.satisfies(version, range))
            .sort((a, b) => {
            return semver.gt(b, a);
        });
    });
}
exports.getSatisfiesVersions = getSatisfiesVersions;
/**
 * 根据指定 version 获取符合 semver 规范的最新版本号
 *
 * @param {String} baseVersion 指定的基准 version
 * @param {Array} versions
 */
function getLatestSemverVersion(baseVersion, versions) {
    versions = versions
        .filter((version) => semver.satisfies(version, `^${baseVersion}`))
        .sort((a, b) => {
        return semver.gt(b, a);
    });
    return versions[0];
}
/**
 * 根据指定 version 和包名获取符合 semver 规范的最新版本号
 *
 * @param {String} npm 包名
 * @param {String} baseVersion 指定的基准 version
 */
function getNpmLatestSemverVersion(npm, baseVersion, registry) {
    return getVersions(npm, registry).then((versions) => {
        return getLatestSemverVersion(baseVersion, versions);
    });
}
exports.getNpmLatestSemverVersion = getNpmLatestSemverVersion;
/**
 * 获取某个 npm 的最新版本号
 *
 * @param {String} npm
 */
function getLatestVersion(npm, registry) {
    return getNpmInfo(npm, registry).then((data) => {
        if (!data['dist-tags'] || !data['dist-tags'].latest) {
            console.error('没有 latest 版本号', data);
            return Promise.reject(new Error('Error: 没有 latest 版本号'));
        }
        const latestVersion = data['dist-tags'].latest;
        return latestVersion;
    });
}
exports.getLatestVersion = getLatestVersion;
function isAliNpm(npmName) {
    return /^(@alife|@ali|@alipay|@kaola)\//.test(npmName);
}
exports.isAliNpm = isAliNpm;
function getNpmRegistry(npmName = '') {
    if (process.env.REGISTRY) {
        return process.env.REGISTRY;
    }
    if (isAliNpm(npmName)) {
        return constant_1.ALI_NPM_REGISTRY;
    }
    return 'https://registry.npmmirror.com';
}
exports.getNpmRegistry = getNpmRegistry;
function getUnpkgHost(npmName = '') {
    if (process.env.UNPKG) {
        return process.env.UNPKG;
    }
    if (isAliNpm(npmName)) {
        return constant_1.ALI_UNPKG_URL;
    }
    return 'https://unpkg.com';
}
exports.getUnpkgHost = getUnpkgHost;
function getNpmClient(npmName = '') {
    if (process.env.NPM_CLIENT) {
        return process.env.NPM_CLIENT;
    }
    if (isAliNpm(npmName)) {
        return 'tnpm';
    }
    return 'npm';
}
exports.getNpmClient = getNpmClient;
function checkAliInternal() {
    return axios_1.default({
        url: 'https://alilang-intranet.alibaba-inc.com/is_white_list.json',
        timeout: 3 * 1000,
    })
        .then((response) => {
        const data = response.data;
        return response.data && data.content === true && data.hasError === false;
    })
        .catch((err) => {
        return false;
    });
}
exports.checkAliInternal = checkAliInternal;
const packageJSONFilename = 'package.json';
exports.packageJSONFilename = packageJSONFilename;
async function readPackageJSON(projectPath) {
    const packagePath = path.join(projectPath, packageJSONFilename);
    const packagePathIsExist = await fse.pathExists(packagePath);
    if (!packagePathIsExist) {
        // eslint-disable-next-line quotes
        throw new Error("Project's package.json file not found in local environment");
    }
    const content = await fse.readJson(packagePath);
    return content;
}
exports.readPackageJSON = readPackageJSON;
/**
 * 获取已安装在本地的模块版本号
 *
 * @param projectPath
 * @param packageName
 */
function getPackageLocalVersion(projectPath, packageName) {
    const packageJsonPath = path.join(projectPath, 'node_modules', packageName, 'package.json');
    const packageJson = JSON.parse(fse.readFileSync(packageJsonPath, 'utf-8'));
    return packageJson.version;
}
exports.getPackageLocalVersion = getPackageLocalVersion;
