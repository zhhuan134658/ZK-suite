"use strict";

exports.__esModule = true;
exports.getElementById = getElementById;
exports.createBody = createBody;
exports.createComment = createComment;
exports.createEmpty = createEmpty;
exports.createText = createText;
exports.updateText = updateText;
exports.createElement = createElement;
exports.appendChild = appendChild;
exports.removeChild = removeChild;
exports.replaceChild = replaceChild;
exports.insertAfter = insertAfter;
exports.insertBefore = insertBefore;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.removeAttribute = removeAttribute;
exports.setAttribute = setAttribute;
exports.setStyle = setStyle;
exports.beforeRender = beforeRender;
exports.afterRender = afterRender;

var _styleUnit = require("style-unit");

var DriverDOM = _interopRequireWildcard(require("driver-dom"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Use driver-dom in Weex V2

/* global __weex_v2__ */
var isWeexV2 = typeof __weex_v2__ === 'object';
var STYLE = 'style';
var ID = 'id';
var TEXT = 'text';
var CHILDREN = 'children';
var EVENT_PREFIX_REGEXP = /^on[A-Z]/;
var ARIA_PREFIX_REGEXP = /^aria-/;
var HYPHEN_REGEXP = /\-(\w)/;
var EMPTY = '';

function updateWeexTextValue(node) {
  var value = node.children.map(function (child) {
    // Comment node type
    return child.nodeType === 8 ? child.value : EMPTY;
  }).join(EMPTY);
  node.setAttr('value', value);
}

var nodeMaps = {};
/* global __weex_document__ */

var weexDocument = typeof __weex_document__ === 'object' ? __weex_document__ : typeof document === 'object' ? document : null;

function getElementById(id) {
  if (isWeexV2) {
    return document.getElementById(id);
  }

  return nodeMaps[id];
}

function createBody(type, props) {
  if (isWeexV2) {
    return DriverDOM.createBody();
  }

  if (weexDocument.body) {
    return weexDocument.body;
  }

  var documentElement = weexDocument.documentElement;
  var body = weexDocument.createBody(type, props);
  documentElement.appendChild(body);
  return body;
}

function createComment(content) {
  return weexDocument.createComment(content);
}

function createEmpty(component) {
  if (isWeexV2) {
    return DriverDOM.createEmpty(component);
  }

  return createComment(EMPTY);
}

function createText(text, component) {
  if (isWeexV2) {
    return DriverDOM.createText(text, component);
  } // Use comment node type mock text node


  return createComment(text);
}

function updateText(node, text) {
  if (isWeexV2) {
    return DriverDOM.updateText(node, text);
  }

  node.value = text;
  updateWeexTextValue(node.parentNode);
}

function createElement(type, props, component) {
  if (isWeexV2) {
    return DriverDOM.createElement(type, props, component, true);
  }

  var style = {};
  props = props || {};
  var originStyle = props.style;

  if (originStyle) {
    for (var prop in originStyle) {
      style[prop] = (0, _styleUnit.convertUnit)(originStyle[prop], prop);
    }
  }

  var node = weexDocument.createElement(type, {
    style: style
  });

  for (var _prop in props) {
    var value = props[_prop];

    if (_prop === CHILDREN) {
      continue;
    }

    if (value != null) {
      if (_prop === STYLE) {
        continue;
      } else if (EVENT_PREFIX_REGEXP.test(_prop)) {
        var eventName = _prop.slice(2).toLowerCase();

        addEventListener(node, eventName, value, props);
      } else {
        setAttribute(node, _prop, value);
      }
    }
  }

  return node;
}

function appendChild(node, parent) {
  if (isWeexV2) {
    return DriverDOM.appendChild(node, parent);
  }

  parent.appendChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function removeChild(node, parent) {
  if (isWeexV2) {
    return DriverDOM.removeChild(node, parent);
  }

  parent = parent || node.parentNode;
  var id = node.attr && node.attr[ID];

  if (id != null) {
    nodeMaps[id] = null;
  }

  parent.removeChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function replaceChild(newChild, oldChild, parent) {
  if (isWeexV2) {
    return DriverDOM.replaceChild(newChild, oldChild, parent);
  }

  parent = parent || oldChild.parentNode;
  var previousSibling = oldChild.previousSibling;
  var nextSibling = oldChild.nextSibling;
  removeChild(oldChild, parent);

  if (previousSibling) {
    insertAfter(newChild, previousSibling, parent);
  } else if (nextSibling) {
    insertBefore(newChild, nextSibling, parent);
  } else {
    appendChild(newChild, parent);
  }
}

function insertAfter(node, after, parent) {
  if (isWeexV2) {
    return DriverDOM.insertAfter(node, after, parent);
  }

  parent = parent || after.parentNode;
  parent.insertAfter(node, after);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function insertBefore(node, before, parent) {
  if (isWeexV2) {
    return DriverDOM.insertBefore(node, before, parent);
  }

  parent = parent || before.parentNode;
  parent.insertBefore(node, before);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}

function addEventListener(node, eventName, eventHandler, props) {
  if (isWeexV2) {
    return DriverDOM.addEventListener(node, eventName, eventHandler);
  } // https://github.com/apache/incubator-weex/blob/master/runtime/vdom/Element.js#L421


  var params = props[eventName + 'EventParams'];
  return node.addEvent(eventName, eventHandler, params);
}

function removeEventListener(node, eventName, eventHandler) {
  if (isWeexV2) {
    return DriverDOM.removeEventListener(node, eventName, eventHandler);
  }

  return node.removeEvent(eventName, eventHandler);
}

function removeAttribute(node, propKey, propValue) {
  if (isWeexV2) {
    return DriverDOM.removeAttribute(node, propKey);
  }

  if (propKey == ID) {
    nodeMaps[propValue] = null;
  } // Weex native will crash when pass null value


  return node.setAttr(propKey, undefined, false);
}

function setAttribute(node, propKey, propValue, isSvg) {
  if (isWeexV2) {
    return DriverDOM.setAttribute(node, propKey, propValue, isSvg);
  }

  if (propKey == ID) {
    nodeMaps[propValue] = node;
  } // Weex only support `ariaLabel` format, convert `aria-label` format to camelcase


  if (ARIA_PREFIX_REGEXP.test(propKey)) {
    propKey = propKey.replace(HYPHEN_REGEXP, function (m, p) {
      return p.toUpperCase();
    });
  }

  return node.setAttr(propKey, propValue, false);
}

function setStyle(node, style) {
  if (isWeexV2) {
    return DriverDOM.setStyle(node, style, true);
  }

  for (var prop in style) {
    // Translate `rpx` to weex `px`
    style[prop] = (0, _styleUnit.convertUnit)(style[prop], prop);
  }

  node.setStyles(style);
}

function beforeRender() {
  // Turn off batched updates
  weexDocument.open(); // Set `rpx` unit converter

  (0, _styleUnit.setRpx)(1);
}

function afterRender() {
  if (weexDocument.listener && weexDocument.listener.createFinish) {
    weexDocument.listener.createFinish();
  } // Turn on batched updates


  weexDocument.close();
}