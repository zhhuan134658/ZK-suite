function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var defineProperty = createCommonjsModule(function (module) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
});
var _defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);

var isWeb = typeof window !== 'undefined' && 'onload' in window;
var isNode = typeof process !== 'undefined' && !!(process.versions && process.versions.node);
var isWeex = typeof WXEnvironment !== 'undefined' && WXEnvironment.platform !== 'Web';
var isKraken = typeof __kraken__ !== 'undefined';
var isMiniApp = typeof my !== 'undefined' && my !== null && typeof my.alert !== 'undefined';
var isByteDanceMicroApp = typeof tt !== 'undefined' && tt !== null && typeof tt.showToast !== 'undefined';
var isBaiduSmartProgram = typeof swan !== 'undefined' && swan !== null && typeof swan.showToast !== 'undefined';
var isKuaiShouMiniProgram = typeof ks !== 'undefined' && ks !== null && typeof ks.showToast !== 'undefined'; // In wechat mini program, wx.login is a function
// In wechat mini propgram webview, there is no wx.login, but exist wx.miniProgram
// In bytedance maicro app, there is wx variable.

var isWeChatMiniProgram = !isByteDanceMicroApp && typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
var isQuickApp = typeof global !== 'undefined' && global !== null && typeof global.callNative !== 'undefined' && !isWeex;
var index = {
  isWeb: isWeb,
  isNode: isNode,
  isWeex: isWeex,
  isKraken: isKraken,
  isMiniApp: isMiniApp,
  isByteDanceMicroApp: isByteDanceMicroApp,
  isBaiduSmartProgram: isBaiduSmartProgram,
  isKuaiShouMiniProgram: isKuaiShouMiniProgram,
  isWeChatMiniProgram: isWeChatMiniProgram,
  isQuickApp: isQuickApp
};

var es = {
	__proto__: null,
	isWeb: isWeb,
	isNode: isNode,
	isWeex: isWeex,
	isKraken: isKraken,
	isMiniApp: isMiniApp,
	isByteDanceMicroApp: isByteDanceMicroApp,
	isBaiduSmartProgram: isBaiduSmartProgram,
	isKuaiShouMiniProgram: isKuaiShouMiniProgram,
	isWeChatMiniProgram: isWeChatMiniProgram,
	isQuickApp: isQuickApp,
	'default': index
};

var _env = /*@__PURE__*/getAugmentedNamespace(es);

var lib = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  Object.keys(_env).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _env[key]) return;
    exports[key] = _env[key];
  });
});

var RPX_REG = /"[^"]+"|'[^']+'|url\([^\)]+\)|(\d*\.?\d+)rpx/g;

var __rpx_coefficient__;

var __viewport_width__; // convertUnit method targetPlatform


var targetPlatform = lib.isWeb ? 'web' : lib.isWeex ? 'weex' : ''; // Init toFixed method

var unitPrecision = 4;

var toFixed = function toFixed(number, precision) {
  var multiplier = Math.pow(10, precision + 1);
  var wholeNumber = Math.floor(number * multiplier);
  return Math.round(wholeNumber / 10) * 10 / multiplier;
}; // Dedault decimal px transformer.


var decimalPixelTransformer = function decimalPixelTransformer(rpx, $1) {
  return $1 ? parseFloat(rpx) * getRpx() + 'px' : rpx;
}; // Default decimal vw transformer.


var decimalVWTransformer = function decimalVWTransformer(rpx, $1) {
  return $1 ? toFixed(parseFloat(rpx) / (getViewportWidth() / 100), unitPrecision) + 'vw' : rpx;
}; // Default 1 rpx to 1 px


if (getRpx() === undefined) {
  setRpx(1);
} // Viewport width, default to 750.


if (getViewportWidth() === undefined) {
  setViewportWidth(750);
}

var CustomMap = /*#__PURE__*/function () {
  function CustomMap() {
    _defineProperty(this, "__store", {});
  }

  var _proto = CustomMap.prototype;

  _proto.set = function set(key, value) {
    this.__store[key + "_" + typeof key] = value;
  };

  _proto.get = function get(key) {
    return this.__store[key + "_" + typeof key];
  };

  _proto.has = function has(key) {
    return Object.prototype.hasOwnProperty.call(this.__store, key + "_" + typeof key);
  };

  return CustomMap;
}();
/**
 * Is string contains rpx
 * note: rpx is an alias to rpx
 * @param {String} str
 * @returns {Boolean}
 */


function isRpx(str) {
  return typeof str === 'string' && RPX_REG.test(str);
}
/**
 * Calculate rpx
 * @param {String} str
 * @returns {String}
 */

function calcRpx(str) {
  if (targetPlatform === 'web') {
    // In Web convert rpx to 'vw', same as driver-dom and driver-universal
    // '375rpx' => '50vw'
    return str.replace(RPX_REG, decimalVWTransformer);
  } else if (targetPlatform === 'weex') {
    // In Weex convert rpx to 'px'
    // '375rpx' => 375 * px
    return str.replace(RPX_REG, decimalPixelTransformer);
  } else {
    // Other platform return original value, like Mini-App and WX Mini-Program ...
    // '375rpx' => '375rpx'
    return str;
  }
}
function getRpx() {
  return __rpx_coefficient__;
}
function setRpx(rpx) {
  __rpx_coefficient__ = rpx;
}
function getViewportWidth() {
  return __viewport_width__;
}
function setViewportWidth(viewport) {
  __viewport_width__ = viewport;
}
/**
 * Create a cached version of a pure function.
 * Use the first params as cache key.
 */

function cached(fn) {
  var cache = new CustomMap();
  return function cachedFn() {
    var key = arguments.length <= 0 ? undefined : arguments[0];
    if (!cache.has(key)) cache.set(key, fn.apply(void 0, arguments));
    return cache.get(key);
  };
}
function setTargetPlatform(platform) {
  targetPlatform = platform;
}
/**
 * Convert rpx.
 * @param value
 * @param prop
 * @param platform
 * @return {String} Transformed value.
 */

var convertUnit = cached(function (value, prop, platform) {
  if (platform) {
    setTargetPlatform(platform);
  }

  return isRpx(value) ? calcRpx(value) : value;
});

/**
 * Driver for Web DOM
 **/
// fontWeight -> ntw
// lineHeight|lineClamp -> ne[ch]
// flex|flexGrow|flexPositive|flexShrink|flexNegative|boxFlex|boxFlexGroup|zIndex -> ex(?:s|g|n|p|$)
// order -> ^ord
// zoom -> zoo
// gridArea|gridRow|gridRowEnd|gridRowSpan|gridRowStart|gridColumn|gridColumnEnd|gridColumnSpan|gridColumnStart -> grid
// columnCount -> mnc
// tabSize -> bs
// orphans -> orp
// windows -> ows
// animationIterationCount -> onit
// borderImageOutset|borderImageSlice|borderImageWidth -> erim

var NON_DIMENSIONAL_REG = /opa|ntw|ne[ch]|ex(?:s|g|n|p|$)|^ord|zoo|grid|orp|ows|mnc|^columns$|bs|erim|onit/i;
var EVENT_PREFIX_REG = /^on[A-Z]/;
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var HTML = '__html';
var INNER_HTML = 'innerHTML';
var CLASS_NAME = 'className';
var CLASS = 'class';
var STYLE$1 = 'style';
var CHILDREN$1 = 'children';
var TEXT_CONTENT_ATTR = 'textContent';
var CREATE_ELEMENT = 'createElement';
var CREATE_COMMENT = 'createComment';
var CREATE_TEXT_NODE = 'createTextNode';
var SET_ATTRIBUTE = 'setAttribute';
var REMOVE_ATTRIBUTE = 'removeAttribute';
var SVG_NS = 'http://www.w3.org/2000/svg';
var EMPTY$1 = '';
var WITH_INNERHTML = '__h';

var isSVGMode = false;
/**
 * Camelize CSS property.
 * Vendor prefixes should begin with a capital letter.
 * For example:
 * background-color -> backgroundColor
 * -webkit-transition -> webkitTransition
 */

cached(function (name) {
  return name.replace(/-([a-z])/gi, function (s, g) {
    return g.toUpperCase();
  });
});
var isDimensionalProp = cached(function (prop) {
  return !NON_DIMENSIONAL_REG.test(prop);
});
var isEventProp = cached(function (prop) {
  return EVENT_PREFIX_REG.test(prop);
});
function createBody$1() {
  return document.body;
}
function createEmpty$1(component) {
  component._parent;
  var node;

  {
    node = document[CREATE_COMMENT](EMPTY$1);
  }

  return node;
}
function createText$1(text, component) {
  component._parent;
  var node;

  {
    node = document[CREATE_TEXT_NODE](text);
  }

  return node;
}
function updateText$1(node, text) {
  node[TEXT_CONTENT_ATTR] = text;
}
/**
 * @param {string} type node type
 * @param {object} props elemement properties
 * @param {object} component component instance
 * @param {boolean} __shouldConvertUnitlessToRpx should add unit when missing
 */


function createElement$1(type, props, component, __shouldConvertUnitlessToRpx) {
  var parent = component._parent;
  isSVGMode = type === 'svg' || parent && parent.namespaceURI === SVG_NS;
  var node;

  function createNode() {
    if (isSVGMode) {
      node = document.createElementNS(SVG_NS, type);
    } else {
      node = document[CREATE_ELEMENT](type);
    }
  }

  {
    createNode();
  }

  for (var prop in props) {
    var value = props[prop];
    if (prop === CHILDREN$1) continue;

    if (value != null) {
      if (prop === STYLE$1) {
        setStyle$1(node, value, __shouldConvertUnitlessToRpx);
      } else if (isEventProp(prop)) {
        addEventListener$1(node, prop.slice(2).toLowerCase(), value);
      } else {
        setAttribute$1(node, prop, value, isSVGMode);
      }
    }
  }

  return node;
}
function appendChild$1(node, parent) {
  {
    return parent.appendChild(node);
  }
}
function removeChild$1(node, parent) {
  parent = parent || node.parentNode; // Maybe has been removed when remove child

  if (parent) {
    parent.removeChild(node);
  }
}
function replaceChild$1(newChild, oldChild, parent) {
  parent = parent || oldChild.parentNode;
  parent.replaceChild(newChild, oldChild);
}
function insertAfter$1(node, after, parent) {
  parent = parent || after.parentNode;
  var nextSibling = after.nextSibling;

  if (nextSibling) {
    // Performance improve when node has been existed before nextSibling
    if (nextSibling !== node) {
      insertBefore$1(node, nextSibling, parent);
    }
  } else {
    appendChild$1(node, parent);
  }
}
function insertBefore$1(node, before, parent) {
  parent = parent || before.parentNode;
  parent.insertBefore(node, before);
}
function addEventListener$1(node, eventName, eventHandler) {
  return node.addEventListener(eventName, eventHandler);
}
function removeEventListener$1(node, eventName, eventHandler) {
  return node.removeEventListener(eventName, eventHandler);
}
function removeAttribute$1(node, propKey) {
  if (propKey === DANGEROUSLY_SET_INNER_HTML) {
    return node[INNER_HTML] = null;
  }

  if (propKey === CLASS_NAME) propKey = CLASS;

  if (propKey in node) {
    try {
      // Some node property is readonly when in strict mode
      node[propKey] = null;
    } catch (e) {}
  }

  node[REMOVE_ATTRIBUTE](propKey);
}
function setAttribute$1(node, propKey, propValue, isSvg) {
  if (propKey === DANGEROUSLY_SET_INNER_HTML) {
    // For reduce innerHTML operation to improve performance.
    if (node[INNER_HTML] !== propValue[HTML]) {
      node[INNER_HTML] = propValue[HTML];
    }

    node[WITH_INNERHTML] = true;
    return;
  }

  if (propKey === CLASS_NAME) propKey = CLASS; // Prop for svg can only be set by attribute

  if (!isSvg && propKey in node) {
    try {
      // Some node property is readonly when in strict mode
      node[propKey] = propValue;
    } catch (e) {
      node[SET_ATTRIBUTE](propKey, propValue);
    }
  } else {
    node[SET_ATTRIBUTE](propKey, propValue);
  }
}
/**
 * @param {object} node target node
 * @param {object} style target node style value
 * @param {boolean} __shouldConvertUnitlessToRpx
 */

function setStyle$1(node, style, __shouldConvertUnitlessToRpx) {
  for (var prop in style) {
    var value = style[prop];
    var convertedValue = void 0;

    if (typeof value === 'number' && isDimensionalProp(prop)) {
      if (__shouldConvertUnitlessToRpx) {
        convertedValue = value + 'rpx'; // Transfrom rpx to vw

        convertedValue = convertUnit(convertedValue);
      } else {
        convertedValue = value + 'px';
      }
    } else {
      convertedValue = convertUnit(value);
    } // Support CSS custom properties (variables) like { --main-color: "black" }


    if (prop[0] === '-' && prop[1] === '-') {
      // reference: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/setProperty.
      // style.setProperty do not support Camel-Case style properties.
      node.style.setProperty(prop, convertedValue);
    } else {
      node.style[prop] = convertedValue;
    }
  }
}

/* global __weex_v2__ */

var isWeexV2 = typeof __weex_v2__ === 'object';
var STYLE = 'style';
var ID = 'id';
var TEXT = 'text';
var CHILDREN = 'children';
var EVENT_PREFIX_REGEXP = /^on[A-Z]/;
var ARIA_PREFIX_REGEXP = /^aria-/;
var HYPHEN_REGEXP = /\-(\w)/;
var EMPTY = '';

function updateWeexTextValue(node) {
  var value = node.children.map(function (child) {
    // Comment node type
    return child.nodeType === 8 ? child.value : EMPTY;
  }).join(EMPTY);
  node.setAttr('value', value);
}

var nodeMaps = {};
/* global __weex_document__ */

var weexDocument = typeof __weex_document__ === 'object' ? __weex_document__ : typeof document === 'object' ? document : null;
function getElementById(id) {
  if (isWeexV2) {
    return document.getElementById(id);
  }

  return nodeMaps[id];
}
function createBody(type, props) {
  if (isWeexV2) {
    return createBody$1();
  }

  if (weexDocument.body) {
    return weexDocument.body;
  }

  var documentElement = weexDocument.documentElement;
  var body = weexDocument.createBody(type, props);
  documentElement.appendChild(body);
  return body;
}
function createComment(content) {
  return weexDocument.createComment(content);
}
function createEmpty(component) {
  if (isWeexV2) {
    return createEmpty$1(component);
  }

  return createComment(EMPTY);
}
function createText(text, component) {
  if (isWeexV2) {
    return createText$1(text, component);
  } // Use comment node type mock text node


  return createComment(text);
}
function updateText(node, text) {
  if (isWeexV2) {
    return updateText$1(node, text);
  }

  node.value = text;
  updateWeexTextValue(node.parentNode);
}
function createElement(type, props, component) {
  if (isWeexV2) {
    return createElement$1(type, props, component, true);
  }

  var style = {};
  props = props || {};
  var originStyle = props.style;

  if (originStyle) {
    for (var prop in originStyle) {
      style[prop] = convertUnit(originStyle[prop], prop);
    }
  }

  var node = weexDocument.createElement(type, {
    style: style
  });

  for (var _prop in props) {
    var value = props[_prop];

    if (_prop === CHILDREN) {
      continue;
    }

    if (value != null) {
      if (_prop === STYLE) {
        continue;
      } else if (EVENT_PREFIX_REGEXP.test(_prop)) {
        var eventName = _prop.slice(2).toLowerCase();

        addEventListener(node, eventName, value, props);
      } else {
        setAttribute(node, _prop, value);
      }
    }
  }

  return node;
}
function appendChild(node, parent) {
  if (isWeexV2) {
    return appendChild$1(node, parent);
  }

  parent.appendChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}
function removeChild(node, parent) {
  if (isWeexV2) {
    return removeChild$1(node, parent);
  }

  parent = parent || node.parentNode;
  var id = node.attr && node.attr[ID];

  if (id != null) {
    nodeMaps[id] = null;
  }

  parent.removeChild(node);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}
function replaceChild(newChild, oldChild, parent) {
  if (isWeexV2) {
    return replaceChild$1(newChild, oldChild, parent);
  }

  parent = parent || oldChild.parentNode;
  var previousSibling = oldChild.previousSibling;
  var nextSibling = oldChild.nextSibling;
  removeChild(oldChild, parent);

  if (previousSibling) {
    insertAfter(newChild, previousSibling, parent);
  } else if (nextSibling) {
    insertBefore(newChild, nextSibling, parent);
  } else {
    appendChild(newChild, parent);
  }
}
function insertAfter(node, after, parent) {
  if (isWeexV2) {
    return insertAfter$1(node, after, parent);
  }

  parent = parent || after.parentNode;
  parent.insertAfter(node, after);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}
function insertBefore(node, before, parent) {
  if (isWeexV2) {
    return insertBefore$1(node, before, parent);
  }

  parent = parent || before.parentNode;
  parent.insertBefore(node, before);

  if (parent.type === TEXT) {
    updateWeexTextValue(parent);
  }
}
function addEventListener(node, eventName, eventHandler, props) {
  if (isWeexV2) {
    return addEventListener$1(node, eventName, eventHandler);
  } // https://github.com/apache/incubator-weex/blob/master/runtime/vdom/Element.js#L421


  var params = props[eventName + 'EventParams'];
  return node.addEvent(eventName, eventHandler, params);
}
function removeEventListener(node, eventName, eventHandler) {
  if (isWeexV2) {
    return removeEventListener$1(node, eventName, eventHandler);
  }

  return node.removeEvent(eventName, eventHandler);
}
function removeAttribute(node, propKey, propValue) {
  if (isWeexV2) {
    return removeAttribute$1(node, propKey);
  }

  if (propKey == ID) {
    nodeMaps[propValue] = null;
  } // Weex native will crash when pass null value


  return node.setAttr(propKey, undefined, false);
}
function setAttribute(node, propKey, propValue, isSvg) {
  if (isWeexV2) {
    return setAttribute$1(node, propKey, propValue, isSvg);
  }

  if (propKey == ID) {
    nodeMaps[propValue] = node;
  } // Weex only support `ariaLabel` format, convert `aria-label` format to camelcase


  if (ARIA_PREFIX_REGEXP.test(propKey)) {
    propKey = propKey.replace(HYPHEN_REGEXP, function (m, p) {
      return p.toUpperCase();
    });
  }

  return node.setAttr(propKey, propValue, false);
}
function setStyle(node, style) {
  if (isWeexV2) {
    return setStyle$1(node, style, true);
  }

  for (var prop in style) {
    // Translate `rpx` to weex `px`
    style[prop] = convertUnit(style[prop], prop);
  }

  node.setStyles(style);
}
function beforeRender() {
  // Turn off batched updates
  weexDocument.open(); // Set `rpx` unit converter

  setRpx(1);
}
function afterRender() {
  if (weexDocument.listener && weexDocument.listener.createFinish) {
    weexDocument.listener.createFinish();
  } // Turn on batched updates


  weexDocument.close();
}

export { addEventListener, afterRender, appendChild, beforeRender, createBody, createComment, createElement, createEmpty, createText, getElementById, insertAfter, insertBefore, removeAttribute, removeChild, removeEventListener, replaceChild, setAttribute, setStyle, updateText };
//# sourceMappingURL=driver-weex.mjs.map
