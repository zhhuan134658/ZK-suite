"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var DIRECTIVE = 'x-slot';

function _default(_ref) {
  var t = _ref.types;

  function isSlotDirective(node) {
    return t.isJSXNamespacedName(node) && t.isJSXIdentifier(node.namespace, {
      name: DIRECTIVE
    });
  }

  var slotElementsVisitor = {
    JSXElement: function JSXElement(path) {
      var node = path.node,
          scope = path.scope;

      if (t.isJSXIdentifier(node.openingElement.name, {
        name: 'slot'
      })) {
        var propSlots = '$slots'; // Guess and add props.$slots reference

        if (scope.hasBinding('props')) {
          propSlots = 'props.$slots';
        } else if (!scope.hasBinding(propSlots)) {
          scope.push({
            id: t.identifier(propSlots),
            init: t.conditionalExpression(t.logicalExpression('&&', t.thisExpression(), t.memberExpression(t.thisExpression(), t.identifier('props'))), t.memberExpression(t.memberExpression(t.thisExpression(), t.identifier('props')), t.identifier('$slots')), t.memberExpression(t.memberExpression(t.identifier('arguments'), t.numericLiteral(0), true), t.identifier('$slots'))),
            kind: 'const'
          });
        }

        node.openingElement.name.name = '$slot';
        var attributes = node.openingElement.attributes;
        attributes.push(t.jsxAttribute(t.jsxIdentifier('$slots'), t.jsxExpressionContainer(t.identifier(propSlots))));
        var programPath = path.findParent(function (p) {
          return p.isProgram();
        });

        if (!programPath.__import_slot__) {
          programPath.unshiftContainer('body', t.importDeclaration([t.importSpecifier(t.identifier('$slot'), t.identifier('$slot'))], t.stringLiteral('babel-runtime-jsx-plus')));
          programPath.__import_slot__ = true;
        }
      }
    }
  };
  return {
    visitor: {
      JSXAttribute: function JSXAttribute(path) {
        var node = path.node;

        if (isSlotDirective(node.name)) {
          var slotName = node.name.name.name;
          var slotScope = node.value ? node.value.value : null;
          var currentJSXElementPath = path.findParent(function (p) {
            return p.isJSXElement();
          });
          var parentJSXElementPath = path.findParent(function (p) {
            return p !== currentJSXElementPath && p.isJSXElement() && !/^[a-z]/.test(p.node.openingElement.name.name);
          });

          if (parentJSXElementPath) {
            var attributes = parentJSXElementPath.node.openingElement.attributes;
            var $slotAttribute = attributes.filter(function (jsxAttr) {
              return t.isJSXIdentifier(jsxAttr.name, {
                name: '$slots'
              });
            })[0];

            if ($slotAttribute === undefined) {
              $slotAttribute = t.jsxAttribute(t.jsxIdentifier('$slots'), t.jsxExpressionContainer(t.objectExpression([])));
              attributes.push($slotAttribute);
            }

            var slotProperties = $slotAttribute.value.expression.properties;
            slotProperties.push(t.objectProperty(t.identifier(slotName), t.arrowFunctionExpression(slotScope === null ? [] : [t.identifier(slotScope)], currentJSXElementPath.node)));
            currentJSXElementPath.remove();
          }

          path.remove();
        }
      },
      JSXElement: function JSXElement(path) {
        var node = path.node,
            scope = path.scope; // Prevent JSXElement from being moved by other babel plugins.

        path.traverse(slotElementsVisitor);
      }
    }
  };
}