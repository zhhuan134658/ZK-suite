"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
var DIRECTIVE = 'x-for';
var helperImportedFrom = 'babel-runtime-jsx-plus';
var helperImportedName = 'createList';
var helperLocalName = '__create_list__';

function _default(_ref) {
  var t = _ref.types;

  function getAttrXFor(node) {
    return t.isJSXElement(node) && node.openingElement.attributes.length > 0 && node.openingElement.attributes.find(function (jsxAttr) {
      return t.isJSXAttribute(jsxAttr) && t.isJSXIdentifier(jsxAttr.name, {
        name: DIRECTIVE
      });
    });
  }

  return {
    visitor: {
      Program: function Program(path) {
        path.__listHelperImported = false;
      },
      JSXElement: function JSXElement(path) {
        var node = path.node,
            parentPath = path.parentPath;
        if (node.__listHandled) return;
        node.__listHandled = true;
        var attrXFor = getAttrXFor(node);

        if (attrXFor) {
          // Remove x-for attribute
          node.openingElement.attributes.splice(node.openingElement.attributes.indexOf(attrXFor), 1);
          var rootPath = path.findParent(function (p) {
            return p.isProgram();
          }); // Check stynax.

          if (!t.isJSXExpressionContainer(attrXFor.value)) {
            // TODO: throw err prettier.
            console.warn('ignore x-for due to stynax error.');
            return;
          }

          var expression = attrXFor.value.expression;
          var params = [];
          var iterValue;

          if (t.isBinaryExpression(expression, {
            operator: 'in'
          })) {
            // x-for={(item, index) in value}
            var left = expression.left,
                right = expression.right;
            iterValue = right;

            if (t.isSequenceExpression(left)) {
              // x-for={(item, key) in value}
              params = left.expressions;
            } else if (t.isIdentifier(left)) {
              // x-for={item in value}
              params.push(left);
            } else {
              // x-for={??? in value}
              throw new Error('Stynax error of x-for.');
            }
          } else {
            // x-for={value}, x-for={callExp()}, ...
            iterValue = expression;
          }

          if (rootPath.__listHelperImported === false) {
            var imported = t.identifier(helperImportedName);
            var local = t.identifier(helperLocalName);
            var importDeclaration = t.importDeclaration([t.importSpecifier(local, imported)], t.stringLiteral(helperImportedFrom));
            rootPath.unshiftContainer('body', importDeclaration);
            rootPath.__listHelperImported = true;
          } // `__create_list__.call(this, value, render)`


          var replacer = t.callExpression(t.memberExpression(t.identifier(helperLocalName), t.identifier('call')), [t.thisExpression(), iterValue, t.arrowFunctionExpression(params, node)]);

          if (parentPath.isJSXElement()) {
            path.replaceWith(t.jsxExpressionContainer(replacer));
          } else {
            path.replaceWith(replacer);
          }
        }
      }
    }
  };
}