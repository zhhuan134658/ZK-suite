"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var normalizeColor_1 = require("./normalizeColor");
var NUMBER_REG = /^[-+]?\d*\.?\d+$/;
function convertUnit(val) {
    if (NUMBER_REG.test(val)) {
        return parseFloat(val);
    }
    return val;
}
function measure(value, key) {
    var direction = [];
    if (typeof value === 'number') {
        direction = [value, value, value, value];
    }
    else if (typeof value === 'string') {
        direction = value.split(/\s+/);
        switch (direction.length) {
            case 2:
                direction[2] = direction[0];
                direction[3] = direction[1];
                break;
            case 3:
                direction[3] = direction[1];
                break;
            case 4:
                break;
            default:
                return {};
        }
    }
    var topKey = key + "Top";
    var rightKey = key + "Right";
    var bottomKey = key + "Bottom";
    var leftKey = key + "Left";
    var result = {
        isDeleted: true,
    };
    result[topKey] = convertUnit(direction[0]);
    result[rightKey] = convertUnit(direction[1]);
    result[bottomKey] = convertUnit(direction[2]);
    result[leftKey] = convertUnit(direction[3]);
    return result;
}
var border = function (key, value) {
    var result = {
        isDeleted: true,
    };
    var direction = value && value.split(' ');
    result[key + "Width"] = direction && convertUnit(direction[0]);
    result[key + "Style"] = direction && direction[1];
    result[key + "Color"] = direction && normalizeColor_1.default(direction[2]);
    return result;
};
var toMs = function (value) {
    if (typeof value === 'string') {
        if (/^\./.test(value))
            value = "0" + value; // .5s
        if (/s$/.test(value) && !/ms$/.test(value)) { // 1.5s
            value = parseFloat(value) * 1000;
        }
        else { // 150 or 150ms
            value = parseFloat(value);
        }
    }
    return (value || 0) + "ms";
};
var transitionProperty = function (value) {
    if (value === 'all') {
        value = 'width,height,top,bottom,left,right,backgroundColor,opacity,transform';
    }
    else if (value === 'none' || !value) {
        return { isDeleted: true };
    }
    return {
        transitionProperty: value.replace('background-color', 'backgroundColor'),
    };
};
var transition = function (value) {
    var result = {
        isDeleted: true,
    };
    var options = (value || '')
        .trim()
        .replace(/cubic-bezier\(.*\)/g, function ($0) { return $0.replace(/\s+/g, ''); }) // transition: all 0.2s cubic-bezier( 0.42, 0, 0.58, 1 ) 0s
        .split(/\s+/);
    var property = transitionProperty(options[0] || 'all');
    if (!property.isDeleted)
        result.transitionProperty = property.transitionProperty;
    result.transitionTimingFunction = (options[2] || 'ease').replace(/\s+/g, '');
    result.transitionDuration = toMs(options[1]);
    result.transitionDelay = toMs(options[3]);
    return result;
};
exports.default = {
    border: function (value) {
        return border('border', value);
    },
    borderTop: function (value) {
        return border('borderTop', value);
    },
    borderRight: function (value) {
        return border('borderRight', value);
    },
    borderBottom: function (value) {
        return border('borderBottom', value);
    },
    borderLeft: function (value) {
        return border('borderLeft', value);
    },
    padding: function (value) {
        return measure(value, 'padding');
    },
    margin: function (value) {
        return measure(value, 'margin');
    },
    lineHeight: function (value) {
        return {
            lineHeight: value,
        };
    },
    fontWeight: function (value) {
        return {
            // eslint-disable-next-line @iceworks/best-practices/recommend-polyfill
            fontWeight: value.toString(),
        };
    },
    transition: function (value) {
        return transition(value);
    },
    transitionProperty: function (value) {
        return transitionProperty(value);
    },
    transitionDuration: function (value) {
        return {
            transitionDuration: toMs(value),
        };
    },
    transitionDelay: function (value) {
        return {
            transitionDelay: toMs(value),
        };
    },
    transitionTimingFunction: function (value) {
        return {
            transitionTimingFunction: value.replace(/\s+/g, ''),
        };
    },
};
//# sourceMappingURL=particular.js.map