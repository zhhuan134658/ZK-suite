function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { normalize } from "../common";
import { CONTAINER_NAME } from "../_utils/constant";

function base64toFile(dataUrl, fileName) {
  if (fileName === void 0) {
    fileName = '';
  }

  var dataURLtoBlob = function dataURLtoBlob(base64Data) {
    var arr = base64Data.split(',');
    var mimeStr = 'image/png';
    var mime = arr[0].match(/:(.*?);/);

    if (mime) {
      mimeStr = mime[1];
    }

    var bstr = atob(arr[1]);
    var n = bstr.length;
    var u8arr = new Uint8Array(n);

    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }

    return new Blob([u8arr], {
      type: mimeStr
    });
  };

  var blobToFile = function blobToFile(theBlob, filename) {
    theBlob.lastModifiedDate = new Date();
    theBlob.name = filename;
    return theBlob;
  };

  var blob = dataURLtoBlob(dataUrl);
  var file = blobToFile(blob, fileName);
  return file;
}

function getHeaderMap(xhr) {
  var headers = xhr.getAllResponseHeaders();
  var arr = headers.trim().split(/[\r\n]+/);
  var headerMap = {};
  arr.forEach(function (line) {
    var parts = line.split(': ');

    var _header = parts.shift();

    var value = parts.join(': ');
    headerMap[_header] = value;
  });
  return headerMap;
}

function uploadFile(param) {
  var filePath = param.filePath,
      formData = param.formData,
      success = param.success,
      fail = param.fail,
      complete = param.complete;
  var file = typeof filePath === 'string' ? base64toFile(filePath) : filePath;
  var body = new FormData();

  if (formData) {
    for (var key in formData) {
      if (Object.prototype.hasOwnProperty.call(formData, key)) {
        body.append(key, formData[key]);
      }
    }
  }

  body.append(param.fileName || 'file', file);

  var header = _extends({
    Accept: 'application/json, text/plain, */*'
  }, param.header || {}); // initialize xhr


  var xhr = new XMLHttpRequest();
  var headersReceivedCallback = [];

  xhr.onreadystatechange = function () {
    // header received
    if (xhr && xhr.readyState === 2 && headersReceivedCallback.length > 0) {
      var headers = getHeaderMap(xhr);
      headersReceivedCallback.forEach(function (x) {
        return x(headers);
      });
    }
  }; // Success


  xhr.onload = function () {
    var result = {
      data: xhr.response,
      statusCode: xhr.status,
      errMsg: 'uploadFile:ok',
      header: getHeaderMap(xhr)
    };
    success && success(result);
    complete && complete(result);
  }; // Errors


  xhr.onerror = function () {
    fail && fail({
      errMsg: 'uploadFile:fail error'
    });
    complete && complete({
      errMsg: 'uploadFile:fail error'
    });
  };

  xhr.onabort = function () {
    fail && fail({
      errMsg: 'uploadFile:fail abort'
    });
    complete && complete({
      errMsg: 'uploadFile:fail abort'
    });
  }; // Progress event


  var progressCallback = [];

  xhr.onprogress = function (evt) {
    if (progressCallback.length === 0) {
      return;
    }

    var res = {
      progress: 0,
      totalBytesSent: 0,
      totalBytesExpectedToSend: 0
    };

    if (evt.lengthComputable) {
      res.totalBytesSent = evt.loaded;
      res.totalBytesExpectedToSend = evt.total;
      res.progress = Math.floor(100 * evt.loaded / evt.total);
    }

    progressCallback.forEach(function (x) {
      return x(res);
    });
  }; // check if need add withCredentials


  if (typeof param.withCredentials === 'undefined') {
    if (param.url.indexOf(window.location.host) === -1) {
      xhr.withCredentials = true;
    }
  } else {
    xhr.withCredentials = param.withCredentials;
  }

  xhr.open('POST', param.url, true);

  for (var headerKey in header) {
    if (Object.prototype.hasOwnProperty.call(header, headerKey)) {
      xhr.setRequestHeader(headerKey, String(header[headerKey]));
    }
  } // timeout


  if (param.timeout) {
    xhr.timeout = param.timeout;

    xhr.ontimeout = function () {
      fail && fail({
        errMsg: 'uploadFile:fail timeout'
      });
      complete && complete({
        errMsg: 'uploadFile:fail timeout'
      });
    };
  } // send request


  xhr.send(body);
  return {
    abort: function abort() {
      xhr.abort();
    },
    onProgressUpdate: function onProgressUpdate(cb) {
      progressCallback.push(cb);
    },
    offProgressUpdate: function offProgressUpdate(cb) {
      if (progressCallback.indexOf(cb) !== -1) {
        progressCallback.splice(progressCallback.indexOf(cb), 1);
      }
    },
    onHeadersReceived: function onHeadersReceived(cb) {
      headersReceivedCallback.push(cb);
    },
    offHeadersReceived: function offHeadersReceived(cb) {
      if (headersReceivedCallback.indexOf(cb) !== -1) {
        headersReceivedCallback.splice(headersReceivedCallback.indexOf(cb), 1);
      }
    }
  };
}

export default normalize.upload(uploadFile, CONTAINER_NAME.WEB);