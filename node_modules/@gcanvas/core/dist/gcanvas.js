'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class FillStylePattern {
  constructor(img, pattern) {
    this._style = pattern;
    this._img = img;
  }

}

class FillStyleLinearGradient {
  constructor(x0, y0, x1, y1) {
    this._start_pos = {
      _x: x0,
      _y: y0
    };
    this._end_pos = {
      _x: x1,
      _y: y1
    };
    this._stop_count = 0;
    this._stops = [0, 0, 0, 0, 0];
  }

  addColorStop(pos, color) {
    if (this._stop_count < 5 && 0.0 <= pos && pos <= 1.0) {
      this._stops[this._stop_count] = {
        _pos: pos,
        _color: color
      };
      this._stop_count++;
    }
  }

}

class FillStyleRadialGradient {
  constructor(x0, y0, r0, x1, y1, r1) {
    this._start_pos = {
      _x: x0,
      _y: y0,
      _r: r0
    };
    this._end_pos = {
      _x: x1,
      _y: y1,
      _r: r1
    };
    this._stop_count = 0;
    this._stops = [0, 0, 0, 0, 0];
  }

  addColorStop(pos, color) {
    if (this._stop_count < 5 && 0.0 <= pos && pos <= 1.0) {
      this._stops[this._stop_count] = {
        _pos: pos,
        _color: color
      };
      this._stop_count++;
    }
  }

}

class CanvasRenderingContext2D {
  // _imageMap = new GHashMap();
  // _textureMap = new GHashMap();
  constructor() {
    _defineProperty(this, "_drawCommands", '');

    _defineProperty(this, "_globalAlpha", 1.0);

    _defineProperty(this, "_fillStyle", 'rgb(0,0,0)');

    _defineProperty(this, "_strokeStyle", 'rgb(0,0,0)');

    _defineProperty(this, "_lineWidth", 1);

    _defineProperty(this, "_lineCap", 'butt');

    _defineProperty(this, "_lineJoin", 'miter');

    _defineProperty(this, "_miterLimit", 10);

    _defineProperty(this, "_globalCompositeOperation", 'source-over');

    _defineProperty(this, "_textAlign", 'start');

    _defineProperty(this, "_textBaseline", 'alphabetic');

    _defineProperty(this, "_font", '10px sans-serif');

    _defineProperty(this, "_savedGlobalAlpha", []);

    _defineProperty(this, "timer", null);

    _defineProperty(this, "componentId", null);

    _defineProperty(this, "createRadialGradient", function (x0, y0, r0, x1, y1, r1) {
      return new FillStyleRadialGradient(x0, y0, r0, x1, y1, r1);
    });

    _defineProperty(this, "quadraticCurveTo", function (cpx, cpy, x, y) {
      this._drawCommands = this._drawCommands.concat('u' + cpx + ',' + cpy + ',' + x + ',' + y + ';');
    });

    _defineProperty(this, "strokeText", function (text, x, y) {
      let tmptext = text.replace(/!/g, '!!');
      tmptext = tmptext.replace(/,/g, '!,');
      tmptext = tmptext.replace(/;/g, '!;');
      this._drawCommands = this._drawCommands.concat('U' + tmptext + ',' + x + ',' + y + ',0.0;');
    });

    _defineProperty(this, "measureText", function (text) {
      throw new Error('GCanvas not supported yet');
    });

    _defineProperty(this, "isPointInPath", function (x, y) {
      throw new Error('GCanvas not supported yet');
    });

    this.className = 'CanvasRenderingContext2D';
  }

  set fillStyle(value) {
    this._fillStyle = value;

    if (typeof value == 'string') {
      this._drawCommands = this._drawCommands.concat('F' + value + ';');
    } else if (value instanceof FillStylePattern) {
      const image = value._img;
      CanvasRenderingContext2D.GBridge.bindImageTexture(this.componentId, image.src, image._id);
      this._drawCommands = this._drawCommands.concat('G' + image._id + ',' + value._style + ';');
    } else if (value instanceof FillStyleLinearGradient) {
      var command = 'D' + value._start_pos._x.toFixed(2) + ',' + value._start_pos._y.toFixed(2) + ',' + value._end_pos._x.toFixed(2) + ',' + value._end_pos._y.toFixed(2) + ',' + value._stop_count;

      for (var i = 0; i < value._stop_count; ++i) {
        command += ',' + value._stops[i]._pos + ',' + value._stops[i]._color;
      }

      this._drawCommands = this._drawCommands.concat(command + ';');
    } else if (value instanceof FillStyleRadialGradient) {
      var command = 'H' + value._start_pos._x.toFixed(2) + ',' + value._start_pos._y.toFixed(2) + ',' + value._start_pos._r.toFixed(2) + ',' + value._end_pos._x.toFixed(2) + ',' + value._end_pos._y.toFixed(2) + ',' + value._end_pos._r.toFixed(2) + ',' + value._stop_count;

      for (var i = 0; i < value._stop_count; ++i) {
        command += ',' + value._stops[i]._pos + ',' + value._stops[i]._color;
      }

      this._drawCommands = this._drawCommands.concat(command + ';');
    }
  }

  get fillStyle() {
    return this._fillStyle;
  }

  get globalAlpha() {
    return this._globalAlpha;
  }

  set globalAlpha(value) {
    this._globalAlpha = value;
    this._drawCommands = this._drawCommands.concat('a' + value.toFixed(2) + ';');
  }

  get strokeStyle() {
    return this._strokeStyle;
  }

  set strokeStyle(value) {
    this._strokeStyle = value;

    if (typeof value == 'string') {
      this._drawCommands = this._drawCommands.concat('S' + value + ';');
    } else if (value instanceof FillStylePattern) {
      const image = value._img;
      CanvasRenderingContext2D.GBridge.bindImageTexture(this.componentId, image.src, image._id);
      this._drawCommands = this._drawCommands.concat('G' + image._id + ',' + value._style + ';');
    } else if (value instanceof FillStyleLinearGradient) {
      var command = 'D' + value._start_pos._x.toFixed(2) + ',' + value._start_pos._y.toFixed(2) + ',' + value._end_pos._x.toFixed(2) + ',' + value._end_pos._y.toFixed(2) + ',' + value._stop_count;

      for (var i = 0; i < value._stop_count; ++i) {
        command += ',' + value._stops[i]._pos + ',' + value._stops[i]._color;
      }

      this._drawCommands = this._drawCommands.concat(command + ';');
    } else if (value instanceof FillStyleRadialGradient) {
      var command = 'H' + value._start_pos._x.toFixed(2) + ',' + value._start_pos._y.toFixed(2) + ',' + value._start_pos._r.toFixed(2) + ',' + value._end_pos._x.toFixed(2) + ',' + value._end_pos._y + ','.toFixed(2) + value._end_pos._r.toFixed(2) + ',' + value._stop_count;

      for (var i = 0; i < value._stop_count; ++i) {
        command += ',' + value._stops[i]._pos + ',' + value._stops[i]._color;
      }

      this._drawCommands = this._drawCommands.concat(command + ';');
    }
  }

  get lineWidth() {
    return this._lineWidth;
  }

  set lineWidth(value) {
    this._lineWidth = value;
    this._drawCommands = this._drawCommands.concat('W' + value + ';');
  }

  get lineCap() {
    return this._lineCap;
  }

  set lineCap(value) {
    this._lineCap = value;
    this._drawCommands = this._drawCommands.concat('C' + value + ';');
  }

  get lineJoin() {
    return this._lineJoin;
  }

  set lineJoin(value) {
    this._lineJoin = value;
    this._drawCommands = this._drawCommands.concat('J' + value + ';');
  }

  get miterLimit() {
    return this._miterLimit;
  }

  set miterLimit(value) {
    this._miterLimit = value;
    this._drawCommands = this._drawCommands.concat('M' + value + ';');
  }

  get globalCompositeOperation() {
    return this._globalCompositeOperation;
  }

  set globalCompositeOperation(value) {
    this._globalCompositeOperation = value;
    let mode = 0;

    switch (value) {
      case 'source-over':
        mode = 0;
        break;

      case 'source-atop':
        mode = 5;
        break;

      case 'source-in':
        mode = 0;
        break;

      case 'source-out':
        mode = 2;
        break;

      case 'destination-over':
        mode = 4;
        break;

      case 'destination-atop':
        mode = 4;
        break;

      case 'destination-in':
        mode = 4;
        break;

      case 'destination-out':
        mode = 3;
        break;

      case 'lighter':
        mode = 1;
        break;

      case 'copy':
        mode = 2;
        break;

      case 'xor':
        mode = 6;
        break;

      default:
        mode = 0;
    }

    this._drawCommands = this._drawCommands.concat('B' + mode + ';');
  }

  get textAlign() {
    return this._textAlign;
  }

  set textAlign(value) {
    this._textAlign = value;
    let Align = 0;

    switch (value) {
      case 'start':
        Align = 0;
        break;

      case 'end':
        Align = 1;
        break;

      case 'left':
        Align = 2;
        break;

      case 'center':
        Align = 3;
        break;

      case 'right':
        Align = 4;
        break;

      default:
        Align = 0;
    }

    this._drawCommands = this._drawCommands.concat('A' + Align + ';');
  }

  get textBaseline() {
    return this._textBaseline;
  }

  set textBaseline(value) {
    this._textBaseline = value;
    let baseline = 0;

    switch (value) {
      case 'alphabetic':
        baseline = 0;
        break;

      case 'middle':
        baseline = 1;
        break;

      case 'top':
        baseline = 2;
        break;

      case 'hanging':
        baseline = 3;
        break;

      case 'bottom':
        baseline = 4;
        break;

      case 'ideographic':
        baseline = 5;
        break;

      default:
        baseline = 0;
        break;
    }

    this._drawCommands = this._drawCommands.concat('E' + baseline + ';');
  }

  get font() {
    return this._font;
  }

  set font(value) {
    this._font = value;
    this._drawCommands = this._drawCommands.concat('j' + value + ';');
  }

  setTransform(a, b, c, d, tx, ty) {
    this._drawCommands = this._drawCommands.concat('t' + (a === 1 ? '1' : a.toFixed(2)) + ',' + (b === 0 ? '0' : b.toFixed(2)) + ',' + (c === 0 ? '0' : c.toFixed(2)) + ',' + (d === 1 ? '1' : d.toFixed(2)) + ',' + tx.toFixed(2) + ',' + ty.toFixed(2) + ';');
  }

  transform(a, b, c, d, tx, ty) {
    this._drawCommands = this._drawCommands.concat('f' + (a === 1 ? '1' : a.toFixed(2)) + ',' + (b === 0 ? '0' : b.toFixed(2)) + ',' + (c === 0 ? '0' : c.toFixed(2)) + ',' + (d === 1 ? '1' : d.toFixed(2)) + ',' + tx + ',' + ty + ';');
  }

  resetTransform() {
    this._drawCommands = this._drawCommands.concat('m;');
  }

  scale(a, d) {
    this._drawCommands = this._drawCommands.concat('k' + a.toFixed(2) + ',' + d.toFixed(2) + ';');
  }

  rotate(angle) {
    this._drawCommands = this._drawCommands.concat('r' + angle.toFixed(6) + ';');
  }

  translate(tx, ty) {
    this._drawCommands = this._drawCommands.concat('l' + tx.toFixed(2) + ',' + ty.toFixed(2) + ';');
  }

  save() {
    this._savedGlobalAlpha.push(this._globalAlpha);

    this._drawCommands = this._drawCommands.concat('v;');
  }

  restore() {
    this._drawCommands = this._drawCommands.concat('e;');
    this._globalAlpha = this._savedGlobalAlpha.pop();
  }

  createPattern(img, pattern) {
    return new FillStylePattern(img, pattern);
  }

  createLinearGradient(x0, y0, x1, y1) {
    return new FillStyleLinearGradient(x0, y0, x1, y1);
  }

  strokeRect(x, y, w, h) {
    this._drawCommands = this._drawCommands.concat('s' + x + ',' + y + ',' + w + ',' + h + ';');
  }

  clearRect(x, y, w, h) {
    this._drawCommands = this._drawCommands.concat('c' + x + ',' + y + ',' + w + ',' + h + ';');
  }

  clip() {
    this._drawCommands = this._drawCommands.concat('p;');
  }

  resetClip() {
    this._drawCommands = this._drawCommands.concat('q;');
  }

  closePath() {
    this._drawCommands = this._drawCommands.concat('o;');
  }

  moveTo(x, y) {
    this._drawCommands = this._drawCommands.concat('g' + x.toFixed(2) + ',' + y.toFixed(2) + ';');
  }

  lineTo(x, y) {
    this._drawCommands = this._drawCommands.concat('i' + x.toFixed(2) + ',' + y.toFixed(2) + ';');
  }

  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this._drawCommands = this._drawCommands.concat('z' + cp1x.toFixed(2) + ',' + cp1y.toFixed(2) + ',' + cp2x.toFixed(2) + ',' + cp2y.toFixed(2) + ',' + x.toFixed(2) + ',' + y.toFixed(2) + ';');
  }

  arcTo(x1, y1, x2, y2, radius) {
    this._drawCommands = this._drawCommands.concat('h' + x1 + ',' + y1 + ',' + x2 + ',' + y2 + ',' + radius + ';');
  }

  beginPath() {
    this._drawCommands = this._drawCommands.concat('b;');
  }

  fillRect(x, y, w, h) {
    this._drawCommands = this._drawCommands.concat('n' + x + ',' + y + ',' + w + ',' + h + ';');
  }

  rect(x, y, w, h) {
    this._drawCommands = this._drawCommands.concat('w' + x + ',' + y + ',' + w + ',' + h + ';');
  }

  fill() {
    this._drawCommands = this._drawCommands.concat('L;');
  }

  stroke(path) {
    this._drawCommands = this._drawCommands.concat('x;');
  }

  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    let ianticlockwise = 0;

    if (anticlockwise) {
      ianticlockwise = 1;
    }

    this._drawCommands = this._drawCommands.concat('y' + x.toFixed(2) + ',' + y.toFixed(2) + ',' + radius.toFixed(2) + ',' + startAngle + ',' + endAngle + ',' + ianticlockwise + ';');
  }

  fillText(text, x, y) {
    let tmptext = text.replace(/!/g, '!!');
    tmptext = tmptext.replace(/,/g, '!,');
    tmptext = tmptext.replace(/;/g, '!;');
    this._drawCommands = this._drawCommands.concat('T' + tmptext + ',' + x + ',' + y + ',0.0;');
  }

  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    const numArgs = arguments.length;

    function drawImageCommands() {
      if (numArgs === 3) {
        const x = parseFloat(sx) || 0.0;
        const y = parseFloat(sy) || 0.0;
        return 'd' + image._id + ',0,0,' + image.width + ',' + image.height + ',' + x + ',' + y + ',' + image.width + ',' + image.height + ';';
      } else if (numArgs === 5) {
        const x = parseFloat(sx) || 0.0;
        const y = parseFloat(sy) || 0.0;
        const width = parseInt(sw) || image.width;
        const height = parseInt(sh) || image.height;
        return 'd' + image._id + ',0,0,' + image.width + ',' + image.height + ',' + x + ',' + y + ',' + width + ',' + height + ';';
      } else if (numArgs === 9) {
        sx = parseFloat(sx) || 0.0;
        sy = parseFloat(sy) || 0.0;
        sw = parseInt(sw) || image.width;
        sh = parseInt(sh) || image.height;
        dx = parseFloat(dx) || 0.0;
        dy = parseFloat(dy) || 0.0;
        dw = parseInt(dw) || image.width;
        dh = parseInt(dh) || image.height;
        return 'd' + image._id + ',' + sx + ',' + sy + ',' + sw + ',' + sh + ',' + dx + ',' + dy + ',' + dw + ',' + dh + ';';
      }
    }

    CanvasRenderingContext2D.GBridge.bindImageTexture(this.componentId, image.src, image._id);
    this._drawCommands += drawImageCommands();
  }

}

var GLenum = {
  'DEPTH_BUFFER_BIT': 256,
  'STENCIL_BUFFER_BIT': 1024,
  'COLOR_BUFFER_BIT': 16384,
  'POINTS': 0,
  'LINES': 1,
  'LINE_LOOP': 2,
  'LINE_STRIP': 3,
  'TRIANGLES': 4,
  'TRIANGLE_STRIP': 5,
  'TRIANGLE_FAN': 6,
  'ZERO': 0,
  'ONE': 1,
  'SRC_COLOR': 768,
  'ONE_MINUS_SRC_COLOR': 769,
  'SRC_ALPHA': 770,
  'ONE_MINUS_SRC_ALPHA': 771,
  'DST_ALPHA': 772,
  'ONE_MINUS_DST_ALPHA': 773,
  'DST_COLOR': 774,
  'ONE_MINUS_DST_COLOR': 775,
  'SRC_ALPHA_SATURATE': 776,
  'FUNC_ADD': 32774,
  'BLEND_EQUATION': 32777,
  'BLEND_EQUATION_RGB': 32777,
  'BLEND_EQUATION_ALPHA': 34877,
  'FUNC_SUBTRACT': 32778,
  'FUNC_REVERSE_SUBTRACT': 32779,
  'BLEND_DST_RGB': 32968,
  'BLEND_SRC_RGB': 32969,
  'BLEND_DST_ALPHA': 32970,
  'BLEND_SRC_ALPHA': 32971,
  'CONSTANT_COLOR': 32769,
  'ONE_MINUS_CONSTANT_COLOR': 32770,
  'CONSTANT_ALPHA': 32771,
  'ONE_MINUS_CONSTANT_ALPHA': 32772,
  'BLEND_COLOR': 32773,
  'ARRAY_BUFFER': 34962,
  'ELEMENT_ARRAY_BUFFER': 34963,
  'ARRAY_BUFFER_BINDING': 34964,
  'ELEMENT_ARRAY_BUFFER_BINDING': 34965,
  'STREAM_DRAW': 35040,
  'STATIC_DRAW': 35044,
  'DYNAMIC_DRAW': 35048,
  'BUFFER_SIZE': 34660,
  'BUFFER_USAGE': 34661,
  'CURRENT_VERTEX_ATTRIB': 34342,
  'FRONT': 1028,
  'BACK': 1029,
  'FRONT_AND_BACK': 1032,
  'TEXTURE_2D': 3553,
  'CULL_FACE': 2884,
  'BLEND': 3042,
  'DITHER': 3024,
  'STENCIL_TEST': 2960,
  'DEPTH_TEST': 2929,
  'SCISSOR_TEST': 3089,
  'POLYGON_OFFSET_FILL': 32823,
  'SAMPLE_ALPHA_TO_COVERAGE': 32926,
  'SAMPLE_COVERAGE': 32928,
  'NO_ERROR': 0,
  'INVALID_ENUM': 1280,
  'INVALID_VALUE': 1281,
  'INVALID_OPERATION': 1282,
  'OUT_OF_MEMORY': 1285,
  'CW': 2304,
  'CCW': 2305,
  'LINE_WIDTH': 2849,
  'ALIASED_POINT_SIZE_RANGE': 33901,
  'ALIASED_LINE_WIDTH_RANGE': 33902,
  'CULL_FACE_MODE': 2885,
  'FRONT_FACE': 2886,
  'DEPTH_RANGE': 2928,
  'DEPTH_WRITEMASK': 2930,
  'DEPTH_CLEAR_VALUE': 2931,
  'DEPTH_FUNC': 2932,
  'STENCIL_CLEAR_VALUE': 2961,
  'STENCIL_FUNC': 2962,
  'STENCIL_FAIL': 2964,
  'STENCIL_PASS_DEPTH_FAIL': 2965,
  'STENCIL_PASS_DEPTH_PASS': 2966,
  'STENCIL_REF': 2967,
  'STENCIL_VALUE_MASK': 2963,
  'STENCIL_WRITEMASK': 2968,
  'STENCIL_BACK_FUNC': 34816,
  'STENCIL_BACK_FAIL': 34817,
  'STENCIL_BACK_PASS_DEPTH_FAIL': 34818,
  'STENCIL_BACK_PASS_DEPTH_PASS': 34819,
  'STENCIL_BACK_REF': 36003,
  'STENCIL_BACK_VALUE_MASK': 36004,
  'STENCIL_BACK_WRITEMASK': 36005,
  'VIEWPORT': 2978,
  'SCISSOR_BOX': 3088,
  'COLOR_CLEAR_VALUE': 3106,
  'COLOR_WRITEMASK': 3107,
  'UNPACK_ALIGNMENT': 3317,
  'PACK_ALIGNMENT': 3333,
  'MAX_TEXTURE_SIZE': 3379,
  'MAX_VIEWPORT_DIMS': 3386,
  'SUBPIXEL_BITS': 3408,
  'RED_BITS': 3410,
  'GREEN_BITS': 3411,
  'BLUE_BITS': 3412,
  'ALPHA_BITS': 3413,
  'DEPTH_BITS': 3414,
  'STENCIL_BITS': 3415,
  'POLYGON_OFFSET_UNITS': 10752,
  'POLYGON_OFFSET_FACTOR': 32824,
  'TEXTURE_BINDING_2D': 32873,
  'SAMPLE_BUFFERS': 32936,
  'SAMPLES': 32937,
  'SAMPLE_COVERAGE_VALUE': 32938,
  'SAMPLE_COVERAGE_INVERT': 32939,
  'COMPRESSED_TEXTURE_FORMATS': 34467,
  'DONT_CARE': 4352,
  'FASTEST': 4353,
  'NICEST': 4354,
  'GENERATE_MIPMAP_HINT': 33170,
  'BYTE': 5120,
  'UNSIGNED_BYTE': 5121,
  'SHORT': 5122,
  'UNSIGNED_SHORT': 5123,
  'INT': 5124,
  'UNSIGNED_INT': 5125,
  'FLOAT': 5126,
  'DEPTH_COMPONENT': 6402,
  'ALPHA': 6406,
  'RGB': 6407,
  'RGBA': 6408,
  'LUMINANCE': 6409,
  'LUMINANCE_ALPHA': 6410,
  'UNSIGNED_SHORT_4_4_4_4': 32819,
  'UNSIGNED_SHORT_5_5_5_1': 32820,
  'UNSIGNED_SHORT_5_6_5': 33635,
  'FRAGMENT_SHADER': 35632,
  'VERTEX_SHADER': 35633,
  'MAX_VERTEX_ATTRIBS': 34921,
  'MAX_VERTEX_UNIFORM_VECTORS': 36347,
  'MAX_VARYING_VECTORS': 36348,
  'MAX_COMBINED_TEXTURE_IMAGE_UNITS': 35661,
  'MAX_VERTEX_TEXTURE_IMAGE_UNITS': 35660,
  'MAX_TEXTURE_IMAGE_UNITS': 34930,
  'MAX_FRAGMENT_UNIFORM_VECTORS': 36349,
  'SHADER_TYPE': 35663,
  'DELETE_STATUS': 35712,
  'LINK_STATUS': 35714,
  'VALIDATE_STATUS': 35715,
  'ATTACHED_SHADERS': 35717,
  'ACTIVE_UNIFORMS': 35718,
  'ACTIVE_ATTRIBUTES': 35721,
  'SHADING_LANGUAGE_VERSION': 35724,
  'CURRENT_PROGRAM': 35725,
  'NEVER': 512,
  'LESS': 513,
  'EQUAL': 514,
  'LEQUAL': 515,
  'GREATER': 516,
  'NOTEQUAL': 517,
  'GEQUAL': 518,
  'ALWAYS': 519,
  'KEEP': 7680,
  'REPLACE': 7681,
  'INCR': 7682,
  'DECR': 7683,
  'INVERT': 5386,
  'INCR_WRAP': 34055,
  'DECR_WRAP': 34056,
  'VENDOR': 7936,
  'RENDERER': 7937,
  'VERSION': 7938,
  'NEAREST': 9728,
  'LINEAR': 9729,
  'NEAREST_MIPMAP_NEAREST': 9984,
  'LINEAR_MIPMAP_NEAREST': 9985,
  'NEAREST_MIPMAP_LINEAR': 9986,
  'LINEAR_MIPMAP_LINEAR': 9987,
  'TEXTURE_MAG_FILTER': 10240,
  'TEXTURE_MIN_FILTER': 10241,
  'TEXTURE_WRAP_S': 10242,
  'TEXTURE_WRAP_T': 10243,
  'TEXTURE': 5890,
  'TEXTURE_CUBE_MAP': 34067,
  'TEXTURE_BINDING_CUBE_MAP': 34068,
  'TEXTURE_CUBE_MAP_POSITIVE_X': 34069,
  'TEXTURE_CUBE_MAP_NEGATIVE_X': 34070,
  'TEXTURE_CUBE_MAP_POSITIVE_Y': 34071,
  'TEXTURE_CUBE_MAP_NEGATIVE_Y': 34072,
  'TEXTURE_CUBE_MAP_POSITIVE_Z': 34073,
  'TEXTURE_CUBE_MAP_NEGATIVE_Z': 34074,
  'MAX_CUBE_MAP_TEXTURE_SIZE': 34076,
  'TEXTURE0': 33984,
  'TEXTURE1': 33985,
  'TEXTURE2': 33986,
  'TEXTURE3': 33987,
  'TEXTURE4': 33988,
  'TEXTURE5': 33989,
  'TEXTURE6': 33990,
  'TEXTURE7': 33991,
  'TEXTURE8': 33992,
  'TEXTURE9': 33993,
  'TEXTURE10': 33994,
  'TEXTURE11': 33995,
  'TEXTURE12': 33996,
  'TEXTURE13': 33997,
  'TEXTURE14': 33998,
  'TEXTURE15': 33999,
  'TEXTURE16': 34000,
  'TEXTURE17': 34001,
  'TEXTURE18': 34002,
  'TEXTURE19': 34003,
  'TEXTURE20': 34004,
  'TEXTURE21': 34005,
  'TEXTURE22': 34006,
  'TEXTURE23': 34007,
  'TEXTURE24': 34008,
  'TEXTURE25': 34009,
  'TEXTURE26': 34010,
  'TEXTURE27': 34011,
  'TEXTURE28': 34012,
  'TEXTURE29': 34013,
  'TEXTURE30': 34014,
  'TEXTURE31': 34015,
  'ACTIVE_TEXTURE': 34016,
  'REPEAT': 10497,
  'CLAMP_TO_EDGE': 33071,
  'MIRRORED_REPEAT': 33648,
  'FLOAT_VEC2': 35664,
  'FLOAT_VEC3': 35665,
  'FLOAT_VEC4': 35666,
  'INT_VEC2': 35667,
  'INT_VEC3': 35668,
  'INT_VEC4': 35669,
  'BOOL': 35670,
  'BOOL_VEC2': 35671,
  'BOOL_VEC3': 35672,
  'BOOL_VEC4': 35673,
  'FLOAT_MAT2': 35674,
  'FLOAT_MAT3': 35675,
  'FLOAT_MAT4': 35676,
  'SAMPLER_2D': 35678,
  'SAMPLER_CUBE': 35680,
  'VERTEX_ATTRIB_ARRAY_ENABLED': 34338,
  'VERTEX_ATTRIB_ARRAY_SIZE': 34339,
  'VERTEX_ATTRIB_ARRAY_STRIDE': 34340,
  'VERTEX_ATTRIB_ARRAY_TYPE': 34341,
  'VERTEX_ATTRIB_ARRAY_NORMALIZED': 34922,
  'VERTEX_ATTRIB_ARRAY_POINTER': 34373,
  'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING': 34975,
  'IMPLEMENTATION_COLOR_READ_TYPE': 35738,
  'IMPLEMENTATION_COLOR_READ_FORMAT': 35739,
  'COMPILE_STATUS': 35713,
  'LOW_FLOAT': 36336,
  'MEDIUM_FLOAT': 36337,
  'HIGH_FLOAT': 36338,
  'LOW_INT': 36339,
  'MEDIUM_INT': 36340,
  'HIGH_INT': 36341,
  'FRAMEBUFFER': 36160,
  'RENDERBUFFER': 36161,
  'RGBA4': 32854,
  'RGB5_A1': 32855,
  'RGB565': 36194,
  'DEPTH_COMPONENT16': 33189,
  'STENCIL_INDEX8': 36168,
  'DEPTH_STENCIL': 34041,
  'RENDERBUFFER_WIDTH': 36162,
  'RENDERBUFFER_HEIGHT': 36163,
  'RENDERBUFFER_INTERNAL_FORMAT': 36164,
  'RENDERBUFFER_RED_SIZE': 36176,
  'RENDERBUFFER_GREEN_SIZE': 36177,
  'RENDERBUFFER_BLUE_SIZE': 36178,
  'RENDERBUFFER_ALPHA_SIZE': 36179,
  'RENDERBUFFER_DEPTH_SIZE': 36180,
  'RENDERBUFFER_STENCIL_SIZE': 36181,
  'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE': 36048,
  'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME': 36049,
  'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL': 36050,
  'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE': 36051,
  'COLOR_ATTACHMENT0': 36064,
  'DEPTH_ATTACHMENT': 36096,
  'STENCIL_ATTACHMENT': 36128,
  'DEPTH_STENCIL_ATTACHMENT': 33306,
  'NONE': 0,
  'FRAMEBUFFER_COMPLETE': 36053,
  'FRAMEBUFFER_INCOMPLETE_ATTACHMENT': 36054,
  'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT': 36055,
  'FRAMEBUFFER_INCOMPLETE_DIMENSIONS': 36057,
  'FRAMEBUFFER_UNSUPPORTED': 36061,
  'FRAMEBUFFER_BINDING': 36006,
  'RENDERBUFFER_BINDING': 36007,
  'MAX_RENDERBUFFER_SIZE': 34024,
  'INVALID_FRAMEBUFFER_OPERATION': 1286,
  'UNPACK_FLIP_Y_WEBGL': 37440,
  'UNPACK_PREMULTIPLY_ALPHA_WEBGL': 37441,
  'CONTEXT_LOST_WEBGL': 37442,
  'UNPACK_COLORSPACE_CONVERSION_WEBGL': 37443,
  'BROWSER_DEFAULT_WEBGL': 37444
};

class WebGLActiveInfo {
  constructor({
    type,
    name,
    size
  }) {
    _defineProperty(this, "className", 'WebGLActiveInfo');

    this.type = type;
    this.name = name;
    this.size = size;
  }

}

function getTransferedObjectUUID(name, id) {
  return `${name.toLowerCase()}-${id}`;
}

const name = 'WebGLBuffer';

function uuid(id) {
  return getTransferedObjectUUID(name, id);
}

class WebGLBuffer {
  constructor(id) {
    _defineProperty(this, "className", name);

    this.id = id;
  }

  uuid() {
    return uuid(this.id);
  }

}

_defineProperty(WebGLBuffer, "uuid", uuid);

const name$1 = 'WebGLFrameBuffer';

function uuid$1(id) {
  return getTransferedObjectUUID(name$1, id);
}

class WebGLFramebuffer {
  constructor(id) {
    _defineProperty(this, "className", name$1);

    this.id = id;
  }

  uuid() {
    return uuid$1(this.id);
  }

}

_defineProperty(WebGLFramebuffer, "uuid", uuid$1);

const name$2 = 'WebGLRenderBuffer';

function uuid$2(id) {
  return getTransferedObjectUUID(name$2, id);
}

class WebGLRenderbuffer {
  constructor(id) {
    _defineProperty(this, "className", name$2);

    this.id = id;
  }

  uuid() {
    return uuid$2(this.id);
  }

}

_defineProperty(WebGLRenderbuffer, "uuid", uuid$2);

const name$3 = 'WebGLTexture';

function uuid$3(id) {
  return getTransferedObjectUUID(name$3, id);
}

class WebGLTexture {
  constructor(id, type) {
    _defineProperty(this, "className", name$3);

    this.id = id;
    this.type = type;
  }

  uuid() {
    return uuid$3(this.id);
  }

}

_defineProperty(WebGLTexture, "uuid", uuid$3);

const name$4 = 'WebGLProgram';

function uuid$4(id) {
  return getTransferedObjectUUID(name$4, id);
}

class WebGLProgram {
  constructor(id) {
    _defineProperty(this, "className", name$4);

    this.id = id;
  }

  uuid() {
    return uuid$4(this.id);
  }

}

_defineProperty(WebGLProgram, "uuid", uuid$4);

const name$5 = 'WebGLShader';

function uuid$5(id) {
  return getTransferedObjectUUID(name$5, id);
}

class WebGLShader {
  constructor(id, type) {
    _defineProperty(this, "className", name$5);

    this.id = id;
    this.type = type;
  }

  uuid() {
    return uuid$5(this.id);
  }

}

_defineProperty(WebGLShader, "uuid", uuid$5);

class WebGLShaderPrecisionFormat {
  constructor({
    rangeMin,
    rangeMax,
    precision
  }) {
    _defineProperty(this, "className", 'WebGLShaderPrecisionFormat');

    this.rangeMin = rangeMin;
    this.rangeMax = rangeMax;
    this.precision = precision;
  }

}

const name$6 = 'WebGLUniformLocation';

function uuid$6(id) {
  return getTransferedObjectUUID(name$6, id);
}

class WebGLUniformLocation {
  constructor(id, type) {
    _defineProperty(this, "className", name$6);

    this.id = id;
    this.type = type;
  }

  uuid() {
    return uuid$6(this.id);
  }

}

_defineProperty(WebGLUniformLocation, "uuid", uuid$6);

let i = 1;
const GLmethod = {};
GLmethod.activeTexture = i++; // 1

GLmethod.attachShader = i++;
GLmethod.bindAttribLocation = i++;
GLmethod.bindBuffer = i++;
GLmethod.bindFramebuffer = i++;
GLmethod.bindRenderbuffer = i++;
GLmethod.bindTexture = i++;
GLmethod.blendColor = i++;
GLmethod.blendEquation = i++;
GLmethod.blendEquationSeparate = i++; // 10

GLmethod.blendFunc = i++;
GLmethod.blendFuncSeparate = i++;
GLmethod.bufferData = i++;
GLmethod.bufferSubData = i++;
GLmethod.checkFramebufferStatus = i++;
GLmethod.clear = i++;
GLmethod.clearColor = i++;
GLmethod.clearDepth = i++;
GLmethod.clearStencil = i++;
GLmethod.colorMask = i++; // 20

GLmethod.compileShader = i++;
GLmethod.compressedTexImage2D = i++;
GLmethod.compressedTexSubImage2D = i++;
GLmethod.copyTexImage2D = i++;
GLmethod.copyTexSubImage2D = i++;
GLmethod.createBuffer = i++;
GLmethod.createFramebuffer = i++;
GLmethod.createProgram = i++;
GLmethod.createRenderbuffer = i++;
GLmethod.createShader = i++; // 30

GLmethod.createTexture = i++;
GLmethod.cullFace = i++;
GLmethod.deleteBuffer = i++;
GLmethod.deleteFramebuffer = i++;
GLmethod.deleteProgram = i++;
GLmethod.deleteRenderbuffer = i++;
GLmethod.deleteShader = i++;
GLmethod.deleteTexture = i++;
GLmethod.depthFunc = i++;
GLmethod.depthMask = i++; // 40

GLmethod.depthRange = i++;
GLmethod.detachShader = i++;
GLmethod.disable = i++;
GLmethod.disableVertexAttribArray = i++;
GLmethod.drawArrays = i++;
GLmethod.drawArraysInstancedANGLE = i++;
GLmethod.drawElements = i++;
GLmethod.drawElementsInstancedANGLE = i++;
GLmethod.enable = i++;
GLmethod.enableVertexAttribArray = i++; // 50

GLmethod.flush = i++;
GLmethod.framebufferRenderbuffer = i++;
GLmethod.framebufferTexture2D = i++;
GLmethod.frontFace = i++;
GLmethod.generateMipmap = i++;
GLmethod.getActiveAttrib = i++;
GLmethod.getActiveUniform = i++;
GLmethod.getAttachedShaders = i++;
GLmethod.getAttribLocation = i++;
GLmethod.getBufferParameter = i++; // 60

GLmethod.getContextAttributes = i++;
GLmethod.getError = i++;
GLmethod.getExtension = i++;
GLmethod.getFramebufferAttachmentParameter = i++;
GLmethod.getParameter = i++;
GLmethod.getProgramInfoLog = i++;
GLmethod.getProgramParameter = i++;
GLmethod.getRenderbufferParameter = i++;
GLmethod.getShaderInfoLog = i++;
GLmethod.getShaderParameter = i++; // 70

GLmethod.getShaderPrecisionFormat = i++;
GLmethod.getShaderSource = i++;
GLmethod.getSupportedExtensions = i++;
GLmethod.getTexParameter = i++;
GLmethod.getUniform = i++;
GLmethod.getUniformLocation = i++;
GLmethod.getVertexAttrib = i++;
GLmethod.getVertexAttribOffset = i++;
GLmethod.isBuffer = i++;
GLmethod.isContextLost = i++; // 80

GLmethod.isEnabled = i++;
GLmethod.isFramebuffer = i++;
GLmethod.isProgram = i++;
GLmethod.isRenderbuffer = i++;
GLmethod.isShader = i++;
GLmethod.isTexture = i++;
GLmethod.lineWidth = i++;
GLmethod.linkProgram = i++;
GLmethod.pixelStorei = i++;
GLmethod.polygonOffset = i++; // 90

GLmethod.readPixels = i++;
GLmethod.renderbufferStorage = i++;
GLmethod.sampleCoverage = i++;
GLmethod.scissor = i++;
GLmethod.shaderSource = i++;
GLmethod.stencilFunc = i++;
GLmethod.stencilFuncSeparate = i++;
GLmethod.stencilMask = i++;
GLmethod.stencilMaskSeparate = i++;
GLmethod.stencilOp = i++; // 100

GLmethod.stencilOpSeparate = i++;
GLmethod.texImage2D = i++;
GLmethod.texParameterf = i++;
GLmethod.texParameteri = i++;
GLmethod.texSubImage2D = i++;
GLmethod.uniform1f = i++;
GLmethod.uniform1fv = i++;
GLmethod.uniform1i = i++;
GLmethod.uniform1iv = i++;
GLmethod.uniform2f = i++; // 110

GLmethod.uniform2fv = i++;
GLmethod.uniform2i = i++;
GLmethod.uniform2iv = i++;
GLmethod.uniform3f = i++;
GLmethod.uniform3fv = i++;
GLmethod.uniform3i = i++;
GLmethod.uniform3iv = i++;
GLmethod.uniform4f = i++;
GLmethod.uniform4fv = i++;
GLmethod.uniform4i = i++; // 120

GLmethod.uniform4iv = i++;
GLmethod.uniformMatrix2fv = i++;
GLmethod.uniformMatrix3fv = i++;
GLmethod.uniformMatrix4fv = i++;
GLmethod.useProgram = i++;
GLmethod.validateProgram = i++;
GLmethod.vertexAttrib1f = i++; // new

GLmethod.vertexAttrib2f = i++; // new

GLmethod.vertexAttrib3f = i++; // new

GLmethod.vertexAttrib4f = i++; // new       //130

GLmethod.vertexAttrib1fv = i++; // new

GLmethod.vertexAttrib2fv = i++; // new

GLmethod.vertexAttrib3fv = i++; // new

GLmethod.vertexAttrib4fv = i++; // new

GLmethod.vertexAttribPointer = i++;
GLmethod.viewport = i++;

const processArray = (array, checkArrayType = false) => {
  function joinArray(arr, sep) {
    let res = '';

    for (let i = 0; i < arr.length; i++) {
      if (i !== 0) {
        res += sep;
      }

      res += arr[i];
    }

    return res;
  }

  let type = 'Float32Array';

  if (checkArrayType) {
    if (array instanceof Uint8Array) {
      type = 'Uint8Array';
    } else if (array instanceof Uint16Array) {
      type = 'Uint16Array';
    } else if (array instanceof Uint32Array) {
      type = 'Uint32Array';
    } else if (array instanceof Float32Array) {
      type = 'Float32Array';
    } else {
      throw new Error('Check array type failed. Array type is ' + typeof array);
    }
  }

  const ArrayTypes = {
    Uint8Array: 1,
    Uint16Array: 2,
    Uint32Array: 4,
    Float32Array: 14
  };
  return ArrayTypes[type] + ',' + btoa(joinArray(array, ','));
};

class WebGLRenderingContext {
  // static GBridge = null;
  constructor(canvas, _type, attrs) {
    _defineProperty(this, "className", 'WebGLRenderingContext');

    _defineProperty(this, "activeTexture", function (textureUnit) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.activeTexture + ',' + textureUnit, true);
    });

    _defineProperty(this, "attachShader", function (progarm, shader) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.attachShader + ',' + progarm.id + ',' + shader.id, true);
    });

    _defineProperty(this, "bindAttribLocation", function (program, index, name) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bindAttribLocation + ',' + program.id + ',' + index + ',' + name, true);
    });

    _defineProperty(this, "bindBuffer", function (target, buffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bindBuffer + ',' + target + ',' + (buffer ? buffer.id : 0), true);
    });

    _defineProperty(this, "bindFramebuffer", function (target, framebuffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bindFramebuffer + ',' + target + ',' + (framebuffer ? framebuffer.id : 0), true);
    });

    _defineProperty(this, "bindRenderbuffer", function (target, renderBuffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bindRenderbuffer + ',' + target + ',' + (renderBuffer ? renderBuffer.id : 0), true);
    });

    _defineProperty(this, "bindTexture", function (target, texture) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bindTexture + ',' + target + ',' + (texture ? texture.id : 0), true);
    });

    _defineProperty(this, "blendColor", function (r, g, b, a) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.blendColor + ',' + r + ',' + g + ',' + b + ',' + a, true);
    });

    _defineProperty(this, "blendEquation", function (mode) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.blendEquation + ',' + mode, true);
    });

    _defineProperty(this, "blendEquationSeparate", function (modeRGB, modeAlpha) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.blendEquationSeparate + ',' + modeRGB + ',' + modeAlpha, true);
    });

    _defineProperty(this, "blendFunc", function (sfactor, dfactor) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.blendFunc + ',' + sfactor + ',' + dfactor, true);
    });

    _defineProperty(this, "blendFuncSeparate", function (srcRGB, dstRGB, srcAlpha, dstAlpha) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.blendFuncSeparate + ',' + srcRGB + ',' + dstRGB + ',' + srcAlpha + ',' + dstAlpha, true);
    });

    _defineProperty(this, "bufferData", function (target, data, usage) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bufferData + ',' + target + ',' + processArray(data, true) + ',' + usage, true);
    });

    _defineProperty(this, "bufferSubData", function (target, offset, data) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.bufferSubData + ',' + target + ',' + offset + ',' + processArray(data, true), true);
    });

    _defineProperty(this, "checkFramebufferStatus", function (target) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.checkFramebufferStatus + ',' + target);
      return Number(result);
    });

    _defineProperty(this, "clear", function (mask) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.clear + ',' + mask);
      this._canvas._needRender = true;
    });

    _defineProperty(this, "clearColor", function (r, g, b, a) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.clearColor + ',' + r + ',' + g + ',' + b, true);
    });

    _defineProperty(this, "clearDepth", function (depth) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.clearDepth + ',' + depth, true);
    });

    _defineProperty(this, "clearStencil", function (s) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.clearStencil + ',' + s);
    });

    _defineProperty(this, "colorMask", function (r, g, b, a) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.colorMask + ',' + r + ',' + g + ',' + b + ',' + a);
    });

    _defineProperty(this, "compileShader", function (shader) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.compileShader + ',' + shader.id, true);
    });

    _defineProperty(this, "compressedTexImage2D", function (target, level, internalformat, width, height, border, pixels) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.compressedTexImage2D + ',' + target + ',' + level + ',' + internalformat + ',' + width + ',' + height + ',' + border + ',' + processArray(pixels), true);
    });

    _defineProperty(this, "compressedTexSubImage2D", function (target, level, xoffset, yoffset, width, height, format, pixels) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.compressedTexSubImage2D + ',' + target + ',' + level + ',' + xoffset + ',' + yoffset + ',' + width + ',' + height + ',' + format + ',' + processArray(pixels), true);
    });

    _defineProperty(this, "copyTexImage2D", function (target, level, internalformat, x, y, width, height, border) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.copyTexImage2D + ',' + target + ',' + level + ',' + internalformat + ',' + x + ',' + y + ',' + width + ',' + height + ',' + border, true);
    });

    _defineProperty(this, "copyTexSubImage2D", function (target, level, xoffset, yoffset, x, y, width, height) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.copyTexSubImage2D + ',' + target + ',' + level + ',' + xoffset + ',' + yoffset + ',' + x + ',' + y + ',' + width + ',' + height);
    });

    _defineProperty(this, "createBuffer", function () {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createBuffer + '');
      const buffer = new WebGLBuffer(result);

      this._map.set(buffer.uuid(), buffer);

      return buffer;
    });

    _defineProperty(this, "createFramebuffer", function () {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createFramebuffer + '');
      const framebuffer = new WebGLFramebuffer(result);

      this._map.set(framebuffer.uuid(), framebuffer);

      return framebuffer;
    });

    _defineProperty(this, "createProgram", function () {
      const id = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createProgram + '');
      const program = new WebGLProgram(id);

      this._map.set(program.uuid(), program);

      return program;
    });

    _defineProperty(this, "createRenderbuffer", function () {
      const id = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createRenderbuffer + '');
      const renderBuffer = new WebGLRenderbuffer(id);

      this._map.set(renderBuffer.uuid(), renderBuffer);

      return renderBuffer;
    });

    _defineProperty(this, "createShader", function (type) {
      const id = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createShader + ',' + type);
      const shader = new WebGLShader(id, type);

      this._map.set(shader.uuid(), shader);

      return shader;
    });

    _defineProperty(this, "createTexture", function () {
      const id = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.createTexture + '');
      const texture = new WebGLTexture(id);

      this._map.set(texture.uuid(), texture);

      return texture;
    });

    _defineProperty(this, "cullFace", function (mode) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.cullFace + ',' + mode, true);
    });

    _defineProperty(this, "deleteBuffer", function (buffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteBuffer + ',' + buffer.id, true);
    });

    _defineProperty(this, "deleteFramebuffer", function (framebuffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteFramebuffer + ',' + framebuffer.id, true);
    });

    _defineProperty(this, "deleteProgram", function (program) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteProgram + ',' + program.id, true);
    });

    _defineProperty(this, "deleteRenderbuffer", function (renderbuffer) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteRenderbuffer + ',' + renderbuffer.id, true);
    });

    _defineProperty(this, "deleteShader", function (shader) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteShader + ',' + shader.id, true);
    });

    _defineProperty(this, "deleteTexture", function (texture) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.deleteTexture + ',' + texture.id, true);
    });

    _defineProperty(this, "depthFunc", function (func) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.depthFunc + ',' + func);
    });

    _defineProperty(this, "depthMask", function (flag) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.depthMask + ',' + Number(flag), true);
    });

    _defineProperty(this, "depthRange", function (zNear, zFar) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.depthRange + ',' + zNear + ',' + zFar, true);
    });

    _defineProperty(this, "detachShader", function (program, shader) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.detachShader + ',' + program.id + ',' + shader.id, true);
    });

    _defineProperty(this, "disable", function (cap) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.disable + ',' + cap, true);
    });

    _defineProperty(this, "disableVertexAttribArray", function (index) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.disableVertexAttribArray + ',' + index, true);
    });

    _defineProperty(this, "drawArrays", function (mode, first, count) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.drawArrays + ',' + mode + ',' + first + ',' + count);
      this._canvas._needRender = true;
    });

    _defineProperty(this, "drawElements", function (mode, count, type, offset) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.drawElements + ',' + mode + ',' + count + ',' + type + ',' + offset + ';');
      this._canvas._needRender = true;
    });

    _defineProperty(this, "enable", function (cap) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.enable + ',' + cap, true);
    });

    _defineProperty(this, "enableVertexAttribArray", function (index) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.enableVertexAttribArray + ',' + index, true);
    });

    _defineProperty(this, "flush", function () {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.flush + '');
    });

    _defineProperty(this, "framebufferRenderbuffer", function (target, attachment, textarget, texture, level) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.framebufferRenderbuffer + ',' + target + ',' + attachment + ',' + textarget + ',' + (texture ? texture.id : 0) + ',' + level, true);
    });

    _defineProperty(this, "framebufferTexture2D", function (target, attachment, textarget, texture, level) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.framebufferTexture2D + ',' + target + ',' + attachment + ',' + textarget + ',' + (texture ? texture.id : 0) + ',' + level, true);
    });

    _defineProperty(this, "frontFace", function (mode) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.frontFace + ',' + mode, true);
    });

    _defineProperty(this, "generateMipmap", function (target) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.generateMipmap + ',' + target, true);
    });

    _defineProperty(this, "getActiveAttrib", function (progarm, index) {
      const resultString = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getActiveAttrib + ',' + progarm.id + ',' + index);
      const [type, size, name] = resultString.split(',');
      return new WebGLActiveInfo({
        type: Number(type),
        size: Number(size),
        name
      });
    });

    _defineProperty(this, "getActiveUniform", function (progarm, index) {
      const resultString = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getActiveUniform + ',' + progarm.id + ',' + index);
      const [type, size, name] = resultString.split(',');
      return new WebGLActiveInfo({
        type: Number(type),
        size: Number(size),
        name
      });
    });

    _defineProperty(this, "getAttachedShaders", function (progarm) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getAttachedShaders + ',' + progarm.id);
      const [type, ...ids] = result;
      return ids.map(id => this._map.get(WebGLShader.uuid(id)));
    });

    _defineProperty(this, "getAttribLocation", function (progarm, name) {
      return WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getAttribLocation + ',' + progarm.id + ',' + name);
    });

    _defineProperty(this, "getBufferParameter", function (target, pname) {
      const [type, res] = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getBufferParameter + ',' + target + ',' + pname);
      return res;
    });

    _defineProperty(this, "getError", function () {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getError + '');
      return result;
    });

    _defineProperty(this, "getExtension", function (name) {
      return null;
    });

    _defineProperty(this, "getFramebufferAttachmentParameter", function (target, attachment, pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getFramebufferAttachmentParameter + ',' + target + ',' + attachment + ',' + pname);

      switch (pname) {
        case GLenum.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
          return this._map.get(WebGLRenderbuffer.uuid(result)) || this._map.get(WebGLTexture.uuid(result)) || null;

        default:
          return result;
      }
    });

    _defineProperty(this, "getParameter", function (pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getParameter + ',' + pname);

      switch (pname) {
        case GLenum.VERSION:
          return this._version;

        case GLenum.ARRAY_BUFFER_BINDING: // buffer

        case GLenum.ELEMENT_ARRAY_BUFFER_BINDING:
          // buffer
          return this._map.get(WebGLBuffer.uuid(result)) || null;

        case GLenum.CURRENT_PROGRAM:
          // program
          return this._map.get(WebGLProgram.uuid(result)) || null;

        case GLenum.FRAMEBUFFER_BINDING:
          // framebuffer
          return this._map.get(WebGLFramebuffer.uuid(result)) || null;

        case GLenum.RENDERBUFFER_BINDING:
          // renderbuffer
          return this._map.get(WebGLRenderbuffer.uuid(result)) || null;

        case GLenum.TEXTURE_BINDING_2D: // texture

        case GLenum.TEXTURE_BINDING_CUBE_MAP:
          // texture
          return this._map.get(WebGLTexture.uuid(result)) || null;

        case GLenum.ALIASED_LINE_WIDTH_RANGE: // Float32Array

        case GLenum.ALIASED_POINT_SIZE_RANGE: // Float32Array

        case GLenum.BLEND_COLOR: // Float32Array

        case GLenum.COLOR_CLEAR_VALUE: // Float32Array

        case GLenum.DEPTH_RANGE: // Float32Array

        case GLenum.MAX_VIEWPORT_DIMS: // Int32Array

        case GLenum.SCISSOR_BOX: // Int32Array

        case GLenum.VIEWPORT: // Int32Array

        case GLenum.COMPRESSED_TEXTURE_FORMATS: // Uint32Array

        default:
          const [type, ...res] = result.split(',');

          if (res.length === 1) {
            return Number(res[0]);
          } else {
            return res.map(Number);
          }

      }
    });

    _defineProperty(this, "getProgramInfoLog", function (progarm) {
      return WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getProgramInfoLog + ',' + progarm.id);
    });

    _defineProperty(this, "getProgramParameter", function (program, pname) {
      const res = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getProgramParameter + ',' + program.id + ',' + pname);
      const [type, result] = res.split(',').map(i => parseInt(i));

      if (type === 1) {
        return Boolean(result);
      } else if (type === 2) {
        return result;
      } else {
        throw new Error('Unrecongized program paramater ' + res + ', type: ' + typeof res);
      }
    });

    _defineProperty(this, "getRenderbufferParameter", function (target, pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getRenderbufferParameter + ',' + target + ',' + pname);
      return result;
    });

    _defineProperty(this, "getShaderInfoLog", function (shader) {
      return WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getShaderInfoLog + ',' + shader.id);
    });

    _defineProperty(this, "getShaderParameter", function (shader, pname) {
      return WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getShaderParameter + ',' + shader.id + ',' + pname);
    });

    _defineProperty(this, "getShaderPrecisionFormat", function (shaderType, precisionType) {
      const [rangeMin, rangeMax, precision] = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getShaderPrecisionFormat + ',' + shaderType + ',' + precisionType);
      const shaderPrecisionFormat = new WebGLShaderPrecisionFormat({
        rangeMin: Number(rangeMin),
        rangeMax: Number(rangeMax),
        precision: Number(precision)
      });
      return shaderPrecisionFormat;
    });

    _defineProperty(this, "getShaderSource", function (shader) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getShaderSource + ',' + shader.id);
      return result;
    });

    _defineProperty(this, "getSupportedExtensions", function () {
      return Object.keys({});
    });

    _defineProperty(this, "getTexParameter", function (target, pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getTexParameter + ',' + target + ',' + pname);
      return result;
    });

    _defineProperty(this, "getUniformLocation", function (program, name) {
      const id = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getUniformLocation + ',' + program.id + ',' + name);

      if (id === -1) {
        return null;
      } else {
        return new WebGLUniformLocation(Number(id));
      }
    });

    _defineProperty(this, "getVertexAttrib", function (index, pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getVertexAttrib + ',' + index + ',' + pname);

      switch (pname) {
        case GLenum.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
          return this._map.get(WebGLBuffer.uuid(result)) || null;

        case GLenum.CURRENT_VERTEX_ATTRIB: // Float32Array

        default:
          return result;
      }
    });

    _defineProperty(this, "getVertexAttribOffset", function (index, pname) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.getVertexAttribOffset + ',' + index + ',' + pname);
      return Number(result);
    });

    _defineProperty(this, "isBuffer", function (buffer) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isBuffer + ',' + buffer.id);
      return Boolean(result);
    });

    _defineProperty(this, "isContextLost", function () {
      return false;
    });

    _defineProperty(this, "isEnabled", function (cap) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isEnabled + ',' + cap);
      return Boolean(result);
    });

    _defineProperty(this, "isFramebuffer", function (framebuffer) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isFramebuffer + ',' + framebuffer.id);
      return Boolean(result);
    });

    _defineProperty(this, "isProgram", function (program) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isProgram + ',' + program.id);
      return Boolean(result);
    });

    _defineProperty(this, "isRenderbuffer", function (renderBuffer) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isRenderbuffer + ',' + renderBuffer.id);
      return Boolean(result);
    });

    _defineProperty(this, "isShader", function (shader) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isShader + ',' + shader.id);
      return Boolean(result);
    });

    _defineProperty(this, "isTexture", function (texture) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.isTexture + ',' + texture.id);
      return Boolean(result);
    });

    _defineProperty(this, "lineWidth", function (width) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.lineWidth + ',' + width, true);
    });

    _defineProperty(this, "linkProgram", function (program) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.linkProgram + ',' + program.id, true);
    });

    _defineProperty(this, "pixelStorei", function (pname, param) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.pixelStorei + ',' + pname + ',' + Number(param));
    });

    _defineProperty(this, "polygonOffset", function (factor, units) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.polygonOffset + ',' + factor + ',' + units);
    });

    _defineProperty(this, "readPixels", function (x, y, width, height, format, type, pixels) {
      const result = WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.readPixels + ',' + x + ',' + y + ',' + width + ',' + height + ',' + format + ',' + type);
      return result;
    });

    _defineProperty(this, "renderbufferStorage", function (target, internalFormat, width, height) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.renderbufferStorage + ',' + target + ',' + internalFormat + ',' + width + ',' + height, true);
    });

    _defineProperty(this, "sampleCoverage", function (value, invert) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.sampleCoverage + ',' + value + ',' + Number(invert), true);
    });

    _defineProperty(this, "scissor", function (x, y, width, height) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.scissor + ',' + x + ',' + y + ',' + width + ',' + height, true);
    });

    _defineProperty(this, "shaderSource", function (shader, source) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.shaderSource + ',' + shader.id + ',' + source);
    });

    _defineProperty(this, "stencilFunc", function (func, ref, mask) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilFunc + ',' + func + ',' + ref + ',' + mask, true);
    });

    _defineProperty(this, "stencilFuncSeparate", function (face, func, ref, mask) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilFuncSeparate + ',' + face + ',' + func + ',' + ref + ',' + mask, true);
    });

    _defineProperty(this, "stencilMask", function (mask) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilMask + ',' + mask, true);
    });

    _defineProperty(this, "stencilMaskSeparate", function (face, mask) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilMaskSeparate + ',' + face + ',' + mask, true);
    });

    _defineProperty(this, "stencilOp", function (fail, zfail, zpass) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilOp + ',' + fail + ',' + zfail + ',' + zpass);
    });

    _defineProperty(this, "stencilOpSeparate", function (face, fail, zfail, zpass) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.stencilOp + ',' + face + ',' + fail + ',' + zfail + ',' + zpass, true);
    });

    _defineProperty(this, "texImage2D", function (...args) {
      WebGLRenderingContext.GBridge.texImage2D(this._canvas.id, ...args);
    });

    _defineProperty(this, "texParameterf", function (target, pname, param) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.texParameterf + ',' + target + ',' + pname + ',' + param, true);
    });

    _defineProperty(this, "texParameteri", function (target, pname, param) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.texParameteri + ',' + target + ',' + pname + ',' + param);
    });

    _defineProperty(this, "texSubImage2D", function (...args) {
      WebGLRenderingContext.GBridge.texSubImage2D(this._canvas.id, ...args);
    });

    _defineProperty(this, "uniform1f", function (location, v0) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform1f + ',' + location.id + ',' + v0);
    });

    _defineProperty(this, "uniform1fv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform1fv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform1i", function (location, v0) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform1i + ',' + location.id + ',' + v0 // true
      );
    });

    _defineProperty(this, "uniform1iv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform1iv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform2f", function (location, v0, v1) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform2f + ',' + location.id + ',' + v0 + ',' + v1, true);
    });

    _defineProperty(this, "uniform2fv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform2fv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform2i", function (location, v0, v1) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform2i + ',' + location.id + ',' + v0 + ',' + v1, true);
    });

    _defineProperty(this, "uniform2iv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform2iv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform3f", function (location, v0, v1, v2) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform3f + ',' + location.id + ',' + v0 + ',' + v1 + ',' + v2, true);
    });

    _defineProperty(this, "uniform3fv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform3fv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform3i", function (location, v0, v1, v2) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform3i + ',' + location.id + ',' + v0 + ',' + v1 + ',' + v2, true);
    });

    _defineProperty(this, "uniform3iv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform3iv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform4f", function (location, v0, v1, v2, v3) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform4f + ',' + location.id + ',' + v0 + ',' + v1 + ',' + v2 + ',' + v3, true);
    });

    _defineProperty(this, "uniform4fv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform4fv + ',' + location.id + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniform4i", function (location, v0, v1, v2, v3) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform4i + ',' + location.id + ',' + v0 + ',' + v1 + ',' + v2 + ',' + v3, true);
    });

    _defineProperty(this, "uniform4iv", function (location, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniform4iv + ',' + location.id + ',' + processArray(value, true), true);
    });

    _defineProperty(this, "uniformMatrix2fv", function (location, transpose, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniformMatrix2fv + ',' + location.id + ',' + Number(transpose) + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniformMatrix3fv", function (location, transpose, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniformMatrix3fv + ',' + location.id + ',' + Number(transpose) + ',' + processArray(value), true);
    });

    _defineProperty(this, "uniformMatrix4fv", function (location, transpose, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.uniformMatrix4fv + ',' + location.id + ',' + Number(transpose) + ',' + processArray(value), true);
    });

    _defineProperty(this, "useProgram", function (progarm) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.useProgram + ',' + progarm.id + '', true);
    });

    _defineProperty(this, "validateProgram", function (program) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.validateProgram + ',' + program.id, true);
    });

    _defineProperty(this, "vertexAttrib1f", function (index, v0) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib1f + ',' + index + ',' + v0, true);
    });

    _defineProperty(this, "vertexAttrib2f", function (index, v0, v1) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib2f + ',' + index + ',' + v0 + ',' + v1, true);
    });

    _defineProperty(this, "vertexAttrib3f", function (index, v0, v1, v2) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib3f + ',' + index + ',' + v0 + ',' + v1 + ',' + v2, true);
    });

    _defineProperty(this, "vertexAttrib4f", function (index, v0, v1, v2, v3) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib4f + ',' + index + ',' + v0 + ',' + v1 + ',' + v2 + ',' + v3, true);
    });

    _defineProperty(this, "vertexAttrib1fv", function (index, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib1fv + ',' + index + ',' + processArray(value), true);
    });

    _defineProperty(this, "vertexAttrib2fv", function (index, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib2fv + ',' + index + ',' + processArray(value), true);
    });

    _defineProperty(this, "vertexAttrib3fv", function (index, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib3fv + ',' + index + ',' + processArray(value), true);
    });

    _defineProperty(this, "vertexAttrib4fv", function (index, value) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttrib4fv + ',' + index + ',' + processArray(value), true);
    });

    _defineProperty(this, "vertexAttribPointer", function (index, size, type, normalized, stride, offset) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.vertexAttribPointer + ',' + index + ',' + size + ',' + type + ',' + Number(normalized) + ',' + stride + ',' + offset, true);
    });

    _defineProperty(this, "viewport", function (x, y, width, height) {
      WebGLRenderingContext.GBridge.callNative(this._canvas.id, GLmethod.viewport + ',' + x + ',' + y + ',' + width + ',' + height, true);
    });

    this._canvas = canvas;
    this._type = _type;
    this._version = 'WebGL 1.0';
    this._attrs = attrs;
    this._map = new Map();
    Object.keys(GLenum).forEach(name => Object.defineProperty(this, name, {
      value: GLenum[name]
    }));
  }

  get canvas() {
    return this._canvas;
  }

}

class GCanvas {
  constructor(id, {
    disableAutoSwap
  }) {
    _defineProperty(this, "id", null);

    _defineProperty(this, "_needRender", true);

    this.id = id;
    this._disableAutoSwap = disableAutoSwap;

    if (disableAutoSwap) {
      this._swapBuffers = () => {
        GCanvas.GBridge.render(this.id);
      };
    }
  }

  getContext(type) {
    let context = null;

    if (type.match(/webgl/i)) {
      context = new WebGLRenderingContext(this);
      context.componentId = this.id;

      if (!this._disableAutoSwap) {
        const render = () => {
          if (this._needRender) {
            GCanvas.GBridge.render(this.id);
            this._needRender = false;
          }
        };

        setInterval(render, 16);
      }

      GCanvas.GBridge.callSetContextType(this.id, 1); // 0 for 2d; 1 for webgl
    } else if (type.match(/2d/i)) {
      context = new CanvasRenderingContext2D(this);
      context.componentId = this.id;

      const render = () => {
        const commands = context._drawCommands;
        context._drawCommands = '';
        GCanvas.GBridge.render2d(this.id, commands);
        this._needRender = false;
      };

      setInterval(render, 16);
      GCanvas.GBridge.callSetContextType(this.id, 0);
    } else {
      throw new Error('not supported context ' + type);
    }

    return context;
  }

  reset() {
    GCanvas.GBridge.callReset(this.id);
  }

}

_defineProperty(GCanvas, "GBridge", null);

let id = 1;

const noop = function () {};

class GImage {
  constructor() {
    this._id = id++;
    this._width = 0;
    this._height = 0;
    this._src = undefined;
    this._onload = noop;
    this._onerror = noop;
    this.complete = false;
  }

  get width() {
    return this._width;
  }

  set width(v) {
    this._width = v;
  }

  get height() {
    return this._height;
  }

  set height(v) {
    this._height = v;
  }

  get src() {
    return this._src;
  }

  set src(v) {
    if (v.startsWith('//')) {
      v = 'http:' + v;
    }

    this._src = v;
    GImage.GBridge.perloadImage([this._src, this._id], data => {
      if (typeof data === 'string') {
        data = JSON.parse(data);
      }

      if (data.error) {
        var evt = {
          type: 'error',
          target: this
        };
        this.onerror(evt);
      } else {
        this.complete = true;
        this.width = typeof data.width === 'number' ? data.width : 0;
        this.height = typeof data.height === 'number' ? data.height : 0;
        var evt = {
          type: 'load',
          target: this
        };
        this.onload(evt);
      }
    });
  }

  addEventListener(name, listener) {
    if (name === 'load') {
      this.onload = listener;
    } else if (name === 'error') {
      this.onerror = listener;
    }
  }

  removeEventListener(name, listener) {
    if (name === 'load') {
      this.onload = noop;
    } else if (name === 'error') {
      this.onerror = noop;
    }
  }

  get onload() {
    return this._onload;
  }

  set onload(v) {
    this._onload = v;
  }

  get onerror() {
    return this._onerror;
  }

  set onerror(v) {
    this._onerror = v;
  }

}

_defineProperty(GImage, "GBridge", null);

const isWeex = typeof WXEnvironment !== 'undefined';
const isWeexIOS = isWeex && /ios/i.test(WXEnvironment.platform);
const isWeexAndroid = isWeex && !isWeexIOS;
const GCanvasModule = typeof weex !== 'undefined' && weex.requireModule ? weex.requireModule('gcanvas') : typeof __weex_require__ !== 'undefined' ? __weex_require__('@weex-module/gcanvas') : {};
let isDebugging = false;
let isComboDisabled = false;

const logCommand = function () {
  const methodQuery = [];
  Object.keys(GLmethod).forEach(key => {
    methodQuery[GLmethod[key]] = key;
  });

  const queryMethod = id => {
    return methodQuery[parseInt(id)] || 'NotFoundMethod';
  };

  const logCommand = (id, cmds) => {
    const mId = cmds.split(',')[0];
    const mName = queryMethod(mId);
    console.log(`=== callNative - componentId:${id}; method: ${mName}; cmds: ${cmds}`);
  };

  return logCommand;
}();

function joinArray(arr, sep) {
  let res = '';

  for (let i = 0; i < arr.length; i++) {
    if (i !== 0) {
      res += sep;
    }

    res += arr[i];
  }

  return res;
}

const commandsCache = {};
const GBridge = {
  callEnable: (ref, configArray) => {
    commandsCache[ref] = [];
    return GCanvasModule.enable({
      componentId: ref,
      config: configArray
    });
  },
  callEnableDebug: () => {
    isDebugging = true;
  },
  callEnableDisableCombo: () => {
    isComboDisabled = true;
  },
  callSetContextType: function (componentId, context_type) {
    GCanvasModule.setContextType(context_type, componentId);
  },
  callReset: function (componentId) {
    GCanvasModule.resetComponent && GCanvasModule.resetComponent(componentId);
  },
  render: isWeexIOS ? function (componentId) {
    return GCanvasModule.extendCallNative({
      contextId: componentId,
      type: 0x60000001
    });
  } : function (componentId) {
    return callGCanvasLinkNative(componentId, 0x60000001, 'render');
  },
  render2d: isWeexIOS ? function (componentId, commands) {
    if (isDebugging) {
      console.log('>>> >>> render2d ===');
      console.log('>>> commands: ' + commands);
    }

    GCanvasModule.render(commands, componentId);
  } : function (componentId, commands) {
    if (isDebugging) {
      console.log('>>> >>> render2d ===');
      console.log('>>> commands: ' + commands);
    }

    callGCanvasLinkNative(componentId, 0x20000001, commands);
  },
  callExtendCallNative: isWeexIOS ? function (componentId, cmdArgs) {
    throw 'should not be here anymore ' + cmdArgs;
  } : function (componentId, cmdArgs) {
    throw 'should not be here anymore ' + cmdArgs;
  },
  flushNative: isWeexIOS ? function (componentId) {
    const cmdArgs = joinArray(commandsCache[componentId], ';');
    commandsCache[componentId] = [];

    if (isDebugging) {
      console.log('>>> >>> flush native ===');
      console.log('>>> commands: ' + cmdArgs);
    }

    const result = GCanvasModule.extendCallNative({
      'contextId': componentId,
      'type': 0x60000000,
      'args': cmdArgs
    });
    const res = result && result.result;

    if (isDebugging) {
      console.log('>>> result: ' + res);
    }

    return res;
  } : function (componentId) {
    const cmdArgs = joinArray(commandsCache[componentId], ';');
    commandsCache[componentId] = [];

    if (isDebugging) {
      console.log('>>> >>> flush native ===');
      console.log('>>> commands: ' + cmdArgs);
    }

    const result = callGCanvasLinkNative(componentId, 0x60000000, cmdArgs);

    if (isDebugging) {
      console.log('>>> result: ' + result);
    }

    return result;
  },
  callNative: function (componentId, cmdArgs, cache) {
    if (isDebugging) {
      logCommand(componentId, cmdArgs);
    }

    commandsCache[componentId].push(cmdArgs);

    if (!cache || isComboDisabled) {
      return GBridge.flushNative(componentId);
    } else {
      return undefined;
    }
  },

  texImage2D(componentId, ...args) {
    if (isWeexIOS) {
      if (args.length === 6) {
        const [target, level, internalformat, format, type, image] = args;
        GBridge.callNative(componentId, GLmethod.texImage2D + ',' + 6 + ',' + target + ',' + level + ',' + internalformat + ',' + format + ',' + type + ',' + image.src);
      } else if (args.length === 9) {
        const [target, level, internalformat, width, height, border, format, type, image] = args;
        GBridge.callNative(componentId, GLmethod.texImage2D + ',' + 9 + ',' + target + ',' + level + ',' + internalformat + ',' + width + ',' + height + ',' + border + ',' + +format + ',' + type + ',' + (image ? image.src : 0));
      }
    } else if (isWeexAndroid) {
      if (args.length === 6) {
        const [target, level, internalformat, format, type, image] = args;
        GCanvasModule.texImage2D(componentId, target, level, internalformat, format, type, image.src);
      } else if (args.length === 9) {
        const [target, level, internalformat, width, height, border, format, type, image] = args;
        GCanvasModule.texImage2D(componentId, target, level, internalformat, width, height, border, format, type, image ? image.src : 0);
      }
    }
  },

  texSubImage2D(componentId, target, level, xoffset, yoffset, format, type, image) {
    if (isWeexIOS) {
      if (arguments.length === 8) {
        GBridge.callNative(componentId, GLmethod.texSubImage2D + ',' + 6 + ',' + target + ',' + level + ',' + xoffset + ',' + yoffset, +',' + format + ',' + type + ',' + image.src);
      }
    } else if (isWeexAndroid) {
      GCanvasModule.texSubImage2D(componentId, target, level, xoffset, yoffset, format, type, image.src);
    }
  },

  bindImageTexture(componentId, src, imageId) {
    GCanvasModule.bindImageTexture([src, imageId], componentId);
  },

  perloadImage([url, id], callback) {
    GCanvasModule.preLoadImage([url, id], function (image) {
      image.url = url;
      image.id = id;
      callback(image);
    });
  }

};

const isReactNativeIOS = () => {
  GBridge$1.Platform.OS === 'ios';
};

const isReactNativeAndroid = () => {
  GBridge$1.Platform.OS === 'android';
};

let isDebugging$1 = false;
const GBridge$1 = {
  GCanvasModule: null,
  Platform: null,
  callEnable: (ref, configArray) => {
    return GBridge$1.GCanvasModule.enable({
      componentId: ref,
      config: configArray
    });
  },
  callEnableDebug: () => {
    isDebugging$1 = true;
  },
  callEnableDisableCombo: () => {
  },
  callSetContextType: function (componentId, context_type) {
    GBridge$1.GCanvasModule.setContextType(context_type, componentId);
  },
  render: function (componentId) {
    return GBridge$1.GCanvasModule.extendCallNative({
      contextId: componentId,
      type: 0x60000001
    });
  },
  render2d: function (componentId, commands) {
    if (isDebugging$1) {
      console.log('>>> >>> render2d ===');
      console.log('>>> commands: ' + commands);
    }

    GBridge$1.GCanvasModule.render(commands, componentId);
  },
  flushNative: function (componentId) {},
  callNative: function (componentId, cmdArgs, cache) {},

  texImage2D(componentId, ...args) {
    if (isReactNativeIOS()) {
      if (args.length === 6) {
        const [target, level, internalformat, format, type, image] = args;
        GBridge$1.callNative(componentId, GLmethod.texImage2D + ',' + 6 + ',' + target + ',' + level + ',' + internalformat + ',' + format + ',' + type + ',' + image.src);
      } else if (args.length === 9) {
        const [target, level, internalformat, width, height, border, format, type, image] = args;
        GBridge$1.callNative(componentId, GLmethod.texImage2D + ',' + 9 + ',' + target + ',' + level + ',' + internalformat + ',' + width + ',' + height + ',' + border + ',' + +format + ',' + type + ',' + (image ? image.src : 0));
      }
    } else if (isReactNativeAndroid()) {
      if (args.length === 6) {
        const [target, level, internalformat, format, type, image] = args;
        GBridge$1.GCanvasModule.texImage2D(componentId, target, level, internalformat, format, type, image.src);
      } else if (args.length === 9) {
        const [target, level, internalformat, width, height, border, format, type, image] = args;
        GBridge$1.GCanvasModule.texImage2D(componentId, target, level, internalformat, width, height, border, format, type, image ? image.src : 0);
      }
    }
  },

  texSubImage2D(componentId, target, level, xoffset, yoffset, format, type, image) {
    if (isReactNativeIOS()) {
      if (arguments.length === 8) {
        GBridge$1.callNative(componentId, GLmethod.texSubImage2D + ',' + 6 + ',' + target + ',' + level + ',' + xoffset + ',' + yoffset, +',' + format + ',' + type + ',' + image.src);
      }
    } else if (isReactNativeAndroid()) {
      GBridge$1.GCanvasModule.texSubImage2D(componentId, target, level, xoffset, yoffset, format, type, image.src);
    }
  },

  bindImageTexture(componentId, src, imageId) {
    GBridge$1.GCanvasModule.bindImageTexture([src, imageId], componentId, function (e) {});
  },

  perloadImage([url, id], callback) {
    GBridge$1.GCanvasModule.preLoadImage([url, id], function (image) {
      image.url = url;
      image.id = id;
      callback(image);
    });
  }

};

let Image = GImage;
let WeexBridge = GBridge;
let ReactNativeBridge = GBridge$1;
function enable(el, {
  bridge,
  debug,
  disableAutoSwap,
  disableComboCommands
} = {}) {
  const GBridge = GImage.GBridge = GCanvas.GBridge = WebGLRenderingContext.GBridge = CanvasRenderingContext2D.GBridge = bridge;
  GBridge.callEnable(el.ref, [0, // renderMode: 0--RENDERMODE_WHEN_DIRTY, 1--RENDERMODE_CONTINUOUSLY
  -1, // hybridLayerType:  0--LAYER_TYPE_NONE 1--LAYER_TYPE_SOFTWARE 2--LAYER_TYPE_HARDWARE
  false, // supportScroll
  false, // newCanvasMode
  1, // compatible
  'white', // clearColor
  false // sameLevel: newCanvasMode = true && true => GCanvasView and Webview is same level
  ]);

  if (debug === true) {
    GBridge.callEnableDebug();
  }

  if (disableComboCommands) {
    GBridge.callEnableDisableCombo();
  }

  var canvas = new GCanvas(el.ref, {
    disableAutoSwap
  });
  canvas.width = el.style.width;
  canvas.height = el.style.height;
  return canvas;
}

exports.Image = Image;
exports.ReactNativeBridge = ReactNativeBridge;
exports.WeexBridge = WeexBridge;
exports.enable = enable;
