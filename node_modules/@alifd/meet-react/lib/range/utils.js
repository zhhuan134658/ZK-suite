"use strict";

exports.__esModule = true;
exports.getClosestThumbIndex = getClosestThumbIndex;
exports.getNodeRect = getNodeRect;
exports.getPrecision = getPrecision;
exports.getTouchPosition = getTouchPosition;
exports.handleMarks = handleMarks;
exports.isInRange = isInRange;
exports.noop = noop;
exports.pauseEvent = pauseEvent;
exports.unit = void 0;

var _dom = require("./dom");

var _utils = require("../utils");

var unit = 'rpx';
exports.unit = unit;

function pauseEvent(e) {
  e.stopPropagation();
}

function isMouseEvent(e) {
  return e.pageX;
}

function isTouchEvent(e) {
  return typeof e.changedTouches !== 'undefined';
}

function getTouchPosition(e) {
  var x = 0;

  if (isMouseEvent(e)) {
    x = e.pageX;
  }

  if (isTouchEvent(e)) {
    x = e.changedTouches[0].pageX;
  }

  return (0, _dom.px2rem)(x);
}

function getNodeRect(id) {
  return new Promise(function (resolve) {
    (0, _dom.getComponentRect)(id, function (e) {
      resolve(e.size);
    }, true);
  });
}

function getPrecision(step) {
  var stepString = step.toString();
  var precision = 0;

  if (stepString.indexOf('.') >= 0) {
    precision = stepString.length - stepString.indexOf('.') - 1;
  }

  return precision;
}

function getClosestThumbIndex(position, thumbs) {
  var keys = Object.keys(thumbs);

  if (keys.length === 1) {
    return Promise.resolve(0);
  }

  var index = 0;
  return Promise.all(keys.map(function (key) {
    return getNodeRect(thumbs[key]);
  })).then(function (rects) {
    if (Math.abs(rects[0].left - position) > Math.abs(rects[1].left - position)) {
      index = 1;
    }

    return +keys[index];
  });
}

function handleMarks(marks, min, max) {
  if (marks instanceof Array) {
    return [].concat(marks);
  } else if (marks instanceof Object) {
    return Object.keys(marks).map(parseFloat).sort(function (a, b) {
      return a - b;
    });
  } else if ((0, _utils.isNumber)(marks)) {
    var current = min;
    var arr = [];

    while (current <= max) {
      arr.push(Number(current.toFixed(2)));
      current += (max - min) / marks;
    }

    return arr;
  } else {
    return [];
  }
}

function isInRange(value, range) {
  if (range.length === 1) {
    range.unshift(0);
  }

  return value >= range[0] && value <= range[1];
}

function noop() {}