"use strict";

exports.__esModule = true;
exports.default = void 0;

var _tslib = require("tslib");

var _classnames = _interopRequireDefault(require("classnames"));

var _react = _interopRequireWildcard(require("react"));

var _utils = require("../utils");

var _hooks = require("../utils/hooks");

var _view = _interopRequireDefault(require("../view"));

var _thumb = _interopRequireDefault(require("./thumb"));

var _track = _interopRequireDefault(require("./track"));

var _utils2 = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var Mode;

(function (Mode) {
  Mode["Single"] = "single";
  Mode["Double"] = "double";
})(Mode || (Mode = {}));

function getInitialRatio(max, min, value, defaultValue) {
  var ratio = min;

  if (!(0, _utils.isUndef)(value)) {
    ratio = value;
  } else if (!(0, _utils.isUndef)(defaultValue)) {
    ratio = defaultValue;
  }

  if (!Array.isArray(ratio)) {
    ratio = [ratio];
  }

  return ratio.map(function (item) {
    if (item > max) {
      return max;
    }

    if (item < min) {
      return min;
    }

    return item;
  }).reduce(function (prev, curr, index) {
    var _Object$assign;

    return Object.assign(Object.assign({}, prev), (_Object$assign = {}, _Object$assign[index] = (curr - min) / (max - min), _Object$assign));
  }, {});
}

var Range = function (props) {
  var _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      _props$min = props.min,
      min = _props$min === void 0 ? 0 : _props$min,
      _props$prefix = props.prefix,
      prefix = _props$prefix === void 0 ? 'mt-' : _props$prefix,
      _props$max = props.max,
      max = _props$max === void 0 ? 100 : _props$max,
      _props$mode = props.mode,
      mode = _props$mode === void 0 ? 'single' : _props$mode,
      value = props.value,
      defaultValue = props.defaultValue,
      _props$step = props.step,
      step = _props$step === void 0 ? 1 : _props$step,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$marks = props.marks,
      marks = _props$marks === void 0 ? false : _props$marks,
      _props$marksPosition = props.marksPosition,
      marksPosition = _props$marksPosition === void 0 ? 'below' : _props$marksPosition,
      _props$previewed = props.previewed,
      previewed = _props$previewed === void 0 ? false : _props$previewed,
      className = props.className,
      tooltipVisible = props.tooltipVisible,
      _props$onChange = props.onChange,
      onChange = _props$onChange === void 0 ? _utils2.noop : _props$onChange,
      _props$onProcess = props.onProcess,
      onProcess = _props$onProcess === void 0 ? _utils2.noop : _props$onProcess,
      others = (0, _tslib.__rest)(props, ["size", "min", "prefix", "max", "mode", "value", "defaultValue", "step", "disabled", "marks", "marksPosition", "previewed", "className", "tooltipVisible", "onChange", "onProcess"]);

  var _useState = (0, _react.useState)(getInitialRatio(max, min, value, defaultValue)),
      ratio = _useState[0],
      setRatio = _useState[1];

  var _useState2 = (0, _react.useState)(null),
      active = _useState2[0],
      setActive = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      dragging = _useState3[0],
      setDragging = _useState3[1];

  var _useState4 = (0, _react.useState)(0),
      rangeWidth = _useState4[0],
      setRangeWidth = _useState4[1];

  var id = (0, _hooks.useGuid)('range-');
  var thumbId1 = (0, _hooks.useGuid)('range-thumb-');
  var thumbId2 = (0, _hooks.useGuid)('range-thumb-');
  var isControlled = ('value' in props);
  var handles = mode === Mode.Double ? {
    0: thumbId1,
    1: thumbId2
  } : {
    0: thumbId1
  };

  function getRatioValue(val) {
    return parseFloat((val * (max - min) + min).toFixed((0, _utils2.getPrecision)(step)));
  }

  var points = (0, _react.useMemo)(function () {
    var data = {};

    var dealPoints = function () {
      if (step) {
        for (var point = min; point <= max; point += step) {
          var current = Number(point.toFixed(1));
          data[current] = current;
        }
      }
    };

    if (marks instanceof Array) {
      marks.reduce(function (prev, current) {
        prev[current] = current;
        return prev;
      }, data);
    } else if (marks instanceof Object) {
      data = Object.assign({}, marks);
    }

    dealPoints();
    return Object.keys(data).map(parseFloat).sort(function (a, b) {
      return a - b;
    });
  }, [marks, step, min, max]);

  function getClosestStep(val) {
    var diffs = points.map(function (point) {
      return Math.abs(point - val - min);
    });
    return points[diffs.indexOf(Math.min.apply(Math, diffs))];
  }

  function getValue(newRatio) {
    var result = Object.keys(newRatio).map(function (key) {
      return getRatioValue(newRatio[key]);
    }).sort(function (a, b) {
      return a - b;
    });

    if (result.length === 1) {
      return result[0];
    }

    return result;
  }

  function updatePositionByTouch(e, activeIndex) {
    return (0, _utils2.getNodeRect)(id).then(function (rect) {
      var position = (0, _utils2.getTouchPosition)(e);
      var diff = position - rect.left;
      var offset = Math.max(Math.min(diff, rect.width), 0);
      var closestValue = getClosestStep(offset / rect.width * (max - min));
      var newRatio = Object.assign({}, ratio);

      if (!(0, _utils.isUndef)(activeIndex)) {
        newRatio[activeIndex] = (closestValue - min) / (max - min);
      }

      if (!isControlled) {
        setRatio(newRatio);
      }

      return newRatio;
    });
  }

  function handleTouchStart(e) {
    if (disabled || previewed || dragging) {
      return;
    }

    var position = (0, _utils2.getTouchPosition)(e);
    (0, _utils2.getClosestThumbIndex)(position, handles).then(function (activeIndex) {
      setDragging(true);
      setActive(activeIndex);
      updatePositionByTouch(e, activeIndex).then(function (newRatio) {
        if ((0, _utils.isFunction)(onChange)) {
          onChange(getValue(newRatio), e);
        }
      });
      (0, _utils2.pauseEvent)(e);
    });
  }

  function handleTouchMove(e) {
    if (!dragging) {
      return;
    }

    updatePositionByTouch(e, active).then(function (newRatio) {
      if ((0, _utils.isFunction)(onProcess)) {
        onProcess(getValue(newRatio), e);
      }

      if ((0, _utils.isFunction)(onChange)) {
        onChange(getValue(newRatio), e);
      }
    });
    (0, _utils2.pauseEvent)(e);
  }

  function handleTouchEnd(e) {
    if (!dragging) {
      return;
    }

    setDragging(false);
    setActive(null);
    updatePositionByTouch(e, active).then(function (newRatio) {
      if ((0, _utils.isFunction)(onChange)) {
        onChange(getValue(newRatio), e);
      }
    });
    (0, _utils2.pauseEvent)(e);
  }

  function adjustRatio() {
    var data = {};
    Object.keys(ratio).forEach(function (key) {
      return data[key] = (getClosestStep(ratio[key] * (max - min)) - min) / (max - min);
    });
    setRatio(data);
  }

  (0, _react.useEffect)(function () {
    adjustRatio();
    setTimeout(function () {
      (0, _utils2.getNodeRect)(id).then(function (rect) {
        setRangeWidth(rect.width);
      });
    }, 100);
  }, []);
  (0, _react.useEffect)(function () {
    if (isControlled) {
      setRatio(getInitialRatio(max, min, value, defaultValue));
    }
  }, [value, defaultValue, max, min]);
  var ratioValue = Object.values(ratio).sort(function (a, b) {
    return a - b;
  });
  return /*#__PURE__*/(0, _react.createElement)(_view.default, _extends({}, others, {
    id: id,
    withoutTouch: false,
    className: (0, _classnames.default)(prefix + "range", className),
    onMouseDown: handleTouchStart,
    onMouseMove: handleTouchMove,
    onMouseUp: handleTouchEnd,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  }), /*#__PURE__*/(0, _react.createElement)(_track.default, {
    prefix: prefix,
    size: size,
    min: min,
    max: max,
    marks: marks,
    marksPosition: marksPosition,
    disabled: disabled,
    ratio: ratioValue,
    rangeWidth: rangeWidth
  }), Object.keys(handles).map(function (key) {
    return /*#__PURE__*/(0, _react.createElement)(_thumb.default, {
      prefix: prefix,
      key: key,
      size: size,
      id: handles[key],
      disabled: disabled,
      isActive: "" + active === "" + key,
      tooltipVisible: tooltipVisible,
      offset: ratio[key] * rangeWidth,
      value: getRatioValue(ratio[key])
    });
  }));
};

Range.displayName = 'Range';

var _default = /*#__PURE__*/(0, _react.forwardRef)(Range);

exports.default = _default;