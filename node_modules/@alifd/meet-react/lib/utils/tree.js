"use strict";

exports.__esModule = true;
exports.bfs = bfs;
exports.dfs = dfs;
exports.filter = filter;
exports.find = find;
exports.firstChild = firstChild;
exports.getDataByValues = getDataByValues;
exports.getFirstValue = getFirstValue;
exports.getFullPathByValue = getFullPathByValue;
exports.getItemsFromDataSource = getItemsFromDataSource;
exports.getMaxDepth = getMaxDepth;
exports.getSiblings = getSiblings;

var _fp = require("./fp");

function find(tree, callback) {
  var found;
  dfs(tree, function (node, par, ctrl) {
    if (callback.call(node, node, par)) {
      ctrl.stop = true;
      found = this;
    }
  });
  return found;
}

function getSiblings(tree, val) {
  var p;
  dfs(tree, function (node, par) {
    if (node.value === val) {
      p = par;
    }
  });

  if (!p) {
    return tree;
  } else {
    return filter(tree, function (node, par) {
      return par && par.value === p.value;
    });
  }
}

function filter(tree, callback) {
  var rs = [];
  dfs(tree, function (node, par) {
    if (callback(node, par)) {
      rs.push(node);
    }
  });
  return rs;
}

function dfs(node, callback) {
  var cur;
  var par;
  var children;
  var ctrl;
  var i;
  var nodes = Array.isArray(node) ? node.slice(0).reverse() : [node];
  var parents = [];
  var childrenName = 'children';

  if ((0, _fp.isUndef)(nodes[0]) && nodes.length === 1) {
    return;
  }

  for (i = nodes.length - 1; i >= 0; i--) {
    parents.push(undefined);
  }

  while (nodes.length > 0) {
    cur = nodes.pop();
    par = parents.pop();
    ctrl = {};
    callback.call(cur, cur, par, ctrl);

    if (ctrl.stop) {
      break;
    }

    children = cur && cur[childrenName] ? cur[childrenName] : [];

    for (i = ctrl.cutoff ? -1 : children.length - 1; i >= 0; i--) {
      nodes.push(children[i]);
      parents.push(cur);
    }
  }

  return node;
}

function bfs() {}

function firstChild(tree) {
  var ret = [];

  if (!Array.isArray(tree) || tree.length === 0) {
    return ret;
  }

  var node = tree[0];

  do {
    if (node) {
      ret.push(node);
    }

    node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
  } while (node);

  return ret.map(function (item) {
    return item.value;
  });
}

function getMaxDepth(tree) {
  var depth = 0;
  tree.forEach(function (item) {
    if (item.children) {
      depth = Math.max(depth, getMaxDepth(item.children) + 1);
    } else {
      depth = Math.max(depth, 1);
    }
  });
  return depth;
}

function getFirstValue(tree) {
  if (tree === void 0) {
    tree = [];
  }

  var ret = [];

  if (!Array.isArray(tree) || tree.length === 0) {
    return ret;
  }

  var node = tree[0];

  do {
    if (node) {
      ret.push(node);
    }

    node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
  } while (node);

  return ret.map(function (item) {
    return item.value;
  });
}

function getDataByValues(tree, values) {
  if (tree === void 0) {
    tree = [];
  }

  if (values === void 0) {
    values = [];
  }

  var ret = [];
  var len = values.length;
  var child = tree;

  for (var i = 0; i < len; i++) {
    var val = values[i];
    var l = child.length;
    var flag = false;

    for (var j = 0; j < l; j++) {
      var item = child[j];

      if (item.value === val) {
        flag = true;

        if (Array.isArray(item.children)) {
          child = item.children;
        }

        ret.push(item);
        break;
      }
    }

    if (!flag) {
      ret.push({
        label: val,
        value: val
      });
    }
  }

  return ret;
}

function getItemsFromDataSource(tree, values) {
  if (tree === void 0) {
    tree = [];
  }

  if (values === void 0) {
    values = [];
  }

  if (!(0, _fp.isUndef)(values) && !Array.isArray(values)) {
    values = [values];
  }

  if (!(0, _fp.isValidArray)(tree) || !(0, _fp.isValidArray)(values)) {
    return [];
  }

  return values.map(function (val) {
    return find(tree, function (it) {
      return it.value === val;
    }) || {
      lavel: val,
      value: val
    };
  });
}

function getFullPathByValue(tree, value, key) {
  if (key === void 0) {
    key = 'value';
  }

  var path = [];
  var nodes = Array.isArray(tree) ? tree : [tree];

  function helper(node) {
    for (var i = 0; i < node.length; i++) {
      var item = node[i];

      if (item[key] === value) {
        path.push(value);
        return true;
      }

      if (item.children && helper(item.children)) {
        path.push(item[key]);
        return true;
      }
    }

    return false;
  }

  helper(nodes);
  return path.reverse();
}