"use strict";

exports.__esModule = true;
exports.DEFAULT_FORMAT = void 0;
exports.dateToPicker = dateToPicker;
exports.getColumns = getColumns;
exports.getTimeOption = getTimeOption;
exports.pickerToDate = pickerToDate;
exports.range = range;
exports.rangeOptions = rangeOptions;

var _dayjs = _interopRequireDefault(require("dayjs"));

var _zhCn = _interopRequireDefault(require("../locale/lang/zh-cn"));

var _date = require("../utils/date");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_FORMAT = 'HH:mm:ss';
exports.DEFAULT_FORMAT = DEFAULT_FORMAT;

function range(min, max, step) {
  var result = [];

  for (var i = min; i <= max; i += step) {
    result.push(i);
  }

  return result;
}

function rangeOptions(min, max, step, format) {
  return range(min, max, step).map(function (it) {
    return {
      label: format(it),
      value: it
    };
  });
}

function getTimeOption(props) {
  var _props$format = props.format,
      format = _props$format === void 0 ? DEFAULT_FORMAT : _props$format;
  var hasHour = format.includes('H') || format.includes('h');
  var hasMinute = format.includes('m');
  var hasSecond = format.includes('s');
  var use12Hours = hasHour && format.includes('h');
  return {
    hasHour: hasHour,
    hasMinute: hasMinute,
    hasSecond: hasSecond,
    use12Hours: use12Hours
  };
}

function getColumns(curValue, options, props) {
  var hasHour = options.hasHour,
      hasMinute = options.hasMinute,
      hasSecond = options.hasSecond,
      use12Hours = options.use12Hours;
  var _props$hourStep = props.hourStep,
      hourStep = _props$hourStep === void 0 ? 1 : _props$hourStep,
      _props$minuteStep = props.minuteStep,
      minuteStep = _props$minuteStep === void 0 ? 1 : _props$minuteStep,
      _props$secondStep = props.secondStep,
      secondStep = _props$secondStep === void 0 ? 1 : _props$secondStep,
      _props$disabledHours = props.disabledHours,
      disabledHours = _props$disabledHours === void 0 ? function () {} : _props$disabledHours,
      _props$disabledMinute = props.disabledMinutes,
      disabledMinutes = _props$disabledMinute === void 0 ? function () {} : _props$disabledMinute,
      _props$disabledSecond = props.disabledSeconds,
      disabledSeconds = _props$disabledSecond === void 0 ? function () {} : _props$disabledSecond,
      _props$locale = props.locale,
      locale = _props$locale === void 0 ? _zhCn.default.TimePicker : _props$locale,
      validRangeProp = props.validRange;
  var validRange = (0, _date.getRealRange)(options, props, validRangeProp);
  var dataSource = [];

  var isInRange = function (type, n) {
    if (!validRange) {
      return true;
    }

    var checkOptions = {
      hasHour: true,
      hasMinute: false,
      hasSecond: false,
      use12Hours: false
    };
    var d = (0, _date.cloneDate)(curValue);

    if (type === 'h') {
      d.setHours(n);
    } else if (type === 'm') {
      checkOptions.hasMinute = true;
      d.setMinutes(n);
    } else if (type === 's') {
      checkOptions.hasMinute = true;
      checkOptions.hasSecond = true;
      d.setSeconds(n);
    }

    return (0, _date.checkDateRange)(d, {
      time: checkOptions
    }, validRange) === _date.RANGE_CHECK_RESULT.IN_RANGE;
  };

  var rules = [{
    enable: hasHour,
    min: 0,
    max: use12Hours ? 11 : 23,
    step: hourStep,
    format: function format(n) {
      return (0, _dayjs.default)().hour(n).format(use12Hours ? 'h' : 'H') + locale.hour;
    },
    filter: function filter(n) {
      return isInRange('h', n) && !disabledHours(n);
    }
  }, {
    enable: hasMinute,
    min: 0,
    max: 59,
    step: minuteStep,
    format: function format(n) {
      return n + locale.minute;
    },
    filter: function filter(n) {
      return isInRange('m', n) && !disabledMinutes(n);
    }
  }, {
    enable: hasSecond,
    min: 0,
    max: 59,
    step: secondStep,
    format: function format(n) {
      return n + locale.second;
    },
    filter: function filter(n) {
      return isInRange('s', n) && !disabledSeconds(n);
    }
  }];
  rules.forEach(function (rule) {
    if (!rule.enable) {
      return;
    }

    var opts = rangeOptions(rule.min, rule.max, rule.step, rule.format);

    if (rule.filter) {
      opts = opts.filter(function (it) {
        return rule.filter(it.value);
      });
    }

    dataSource.push(opts);
  });

  if (use12Hours) {
    dataSource.push([{
      label: locale.am,
      value: 'am'
    }, {
      label: locale.pm,
      value: 'pm'
    }]);
  }

  return dataSource;
}

function dateToPicker(d, options) {
  var hasHour = options.hasHour,
      hasMinute = options.hasMinute,
      hasSecond = options.hasSecond,
      use12Hours = options.use12Hours;
  var result = [];

  if (hasHour) {
    var h = d.getHours();
    result.push(use12Hours ? h % 12 : h);
  }

  if (hasMinute) {
    result.push(d.getMinutes());
  }

  if (hasSecond) {
    result.push(d.getSeconds());
  }

  if (use12Hours) {
    result.push(d.getHours() >= 12 ? 'pm' : 'am');
  }

  return result;
}

function pickerToDate(values, options) {
  var hasHour = options.hasHour,
      hasMinute = options.hasMinute,
      hasSecond = options.hasSecond,
      use12Hours = options.use12Hours;
  var d = new Date();

  if (hasHour) {
    var h = values.shift();

    if (use12Hours) {
      var isAm = values.pop() === 'am';

      if (isAm) {
        d.setHours(h);
      } else {
        d.setHours(h + 12);
      }
    } else {
      d.setHours(h);
    }
  } else {
    d.setHours(0);
  }

  if (hasMinute) {
    d.setMinutes(values.shift());
  } else {
    d.setMinutes(0);
  }

  if (hasSecond) {
    d.setSeconds(values.shift());
  } else {
    d.setSeconds(0);
  }

  d.setMilliseconds(0);
  return d;
}