function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

import dayjs from 'dayjs';
import { isInvalidValue } from './fp';

function isDate(obj) {
  return _typeof(obj) === 'object' && obj instanceof Date;
}

export function formatDate(d, format) {
  var invalidStr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  if (!isInvalidValue(d)) {
    var date = dayjs(d);

    if (date.isValid()) {
      return date.format(format);
    }
  }

  return invalidStr;
}
export function isValidDate(obj) {
  return isDate(obj) && !isNaN(obj.getTime());
}
export function toValidDate(from, defaultDate) {
  var res = toDate(from);
  return isValidDate(res) ? res : defaultDate || new Date();
}
export function toDate(from) {
  if (isInvalidValue(from)) {
    return undefined;
  }

  if (isDate(from)) {
    return from;
  }

  if (_typeof(from) === 'object' && typeof from.toDate === 'function') {
    var d = from.toDate();

    if (isDate(d)) {
      return d;
    }
  }

  return toDay(from).toDate();
}
export function toDay(from) {
  return dayjs(from);
}
export function cloneDate(d) {
  return new Date(d.getTime());
}
export function getDateNum(type, d) {
  switch (type) {
    case 'y':
      return d.getFullYear();

    case 'm':
      return d.getMonth();

    case 'd':
      return d.getDate();

    case 'h':
      return d.getHours();

    case 'i':
      return d.getMinutes();

    case 's':
      return d.getSeconds();
  }
}
export function isTypeSame(type, d1, d2) {
  return getDateNum(type, d1) === getDateNum(type, d2);
}
export var RANGE_CHECK_RESULT;

(function (RANGE_CHECK_RESULT) {
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["IN_RANGE"] = 0] = "IN_RANGE";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_HOUR"] = 1] = "SMALL_THAN_HOUR";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_HOUR"] = 2] = "BIGGER_THAN_HOUR";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_MIN"] = 3] = "SMALL_THAN_MIN";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_MIN"] = 4] = "BIGGER_THAN_MIN";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_SEC"] = 5] = "SMALL_THAN_SEC";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_SEC"] = 6] = "BIGGER_THAN_SEC";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_YEAR"] = 7] = "SMALL_THAN_YEAR";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_YEAR"] = 8] = "BIGGER_THAN_YEAR";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_MONTH"] = 9] = "SMALL_THAN_MONTH";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_MONTH"] = 10] = "BIGGER_THAN_MONTH";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["SMALL_THAN_DAY"] = 11] = "SMALL_THAN_DAY";
  RANGE_CHECK_RESULT[RANGE_CHECK_RESULT["BIGGER_THAN_DAY"] = 12] = "BIGGER_THAN_DAY";
})(RANGE_CHECK_RESULT || (RANGE_CHECK_RESULT = {}));

var TIME_PRE_CHECK;

(function (TIME_PRE_CHECK) {
  TIME_PRE_CHECK[TIME_PRE_CHECK["NONE"] = 0] = "NONE";
  TIME_PRE_CHECK[TIME_PRE_CHECK["SKIP"] = 1] = "SKIP";
  TIME_PRE_CHECK[TIME_PRE_CHECK["USE_START"] = 2] = "USE_START";
  TIME_PRE_CHECK[TIME_PRE_CHECK["USE_END"] = 3] = "USE_END";
})(TIME_PRE_CHECK || (TIME_PRE_CHECK = {}));

export function checkDateRange(d, options, validRange) {
  if (!validRange) {
    return RANGE_CHECK_RESULT.IN_RANGE;
  }

  var _validRange = _slicedToArray(validRange, 2),
      startDate = _validRange[0],
      endDate = _validRange[1];

  var isCheckDate = TIME_PRE_CHECK.NONE;

  if (options.date) {
    var _options$date = options.date,
        hasYear = _options$date.hasYear,
        hasMonth = _options$date.hasMonth,
        hasDay = _options$date.hasDay;
    isCheckDate = TIME_PRE_CHECK.SKIP;

    if (hasYear) {
      if (getDateNum('y', startDate) > getDateNum('y', d)) {
        return RANGE_CHECK_RESULT.BIGGER_THAN_YEAR;
      }

      if (getDateNum('y', endDate) < getDateNum('d', d)) {
        return RANGE_CHECK_RESULT.SMALL_THAN_YEAR;
      }
    }

    var isStartYear = isTypeSame('y', d, startDate);
    var isEndYear = isTypeSame('y', d, endDate);

    if ((isStartYear || isEndYear) && hasMonth) {
      if (isStartYear && getDateNum('m', startDate) > getDateNum('m', d)) {
        return RANGE_CHECK_RESULT.BIGGER_THAN_MONTH;
      }

      if (isEndYear && getDateNum('m', endDate) < getDateNum('m', d)) {
        return RANGE_CHECK_RESULT.SMALL_THAN_MONTH;
      }
    }

    var isStartMonth = isStartYear && isTypeSame('m', d, startDate);
    var isEndMonth = isEndYear && isTypeSame('m', d, endDate);

    if (isStartMonth || isEndMonth) {
      if (hasDay) {
        if (isStartMonth && getDateNum('d', startDate) > getDateNum('d', d)) {
          return RANGE_CHECK_RESULT.BIGGER_THAN_DAY;
        }

        if (isEndMonth && getDateNum('d', endDate) < getDateNum('d', d)) {
          return RANGE_CHECK_RESULT.SMALL_THAN_DAY;
        }

        if (isEndMonth && isTypeSame('d', endDate, d)) {
          isCheckDate = TIME_PRE_CHECK.USE_END;
        }

        if (isStartMonth && isTypeSame('d', startDate, d)) {
          isCheckDate = TIME_PRE_CHECK.USE_START;
        }
      } else {
        isCheckDate = isStartMonth ? TIME_PRE_CHECK.USE_START : TIME_PRE_CHECK.USE_END;
      }
    }
  }

  if (options.time && isCheckDate !== TIME_PRE_CHECK.SKIP) {
    var _options$time = options.time,
        hasHour = _options$time.hasHour,
        hasMinute = _options$time.hasMinute,
        hasSecond = _options$time.hasSecond;

    if (hasHour) {
      if (isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('h', startDate) > getDateNum('h', d)) {
        return RANGE_CHECK_RESULT.BIGGER_THAN_HOUR;
      }

      if (isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('h', endDate) < getDateNum('h', d)) {
        return RANGE_CHECK_RESULT.SMALL_THAN_HOUR;
      }
    }

    var isStartHour = isTypeSame('h', d, startDate);
    var isEndHour = isTypeSame('h', d, endDate);

    if ((isStartHour || isEndHour) && hasMinute) {
      if (isStartHour && isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('i', startDate) > getDateNum('i', d)) {
        return RANGE_CHECK_RESULT.BIGGER_THAN_MIN;
      }

      if (isEndHour && isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('i', endDate) < getDateNum('i', d)) {
        return RANGE_CHECK_RESULT.SMALL_THAN_MIN;
      }
    }

    var isStartMinutes = isStartHour && isTypeSame('i', d, startDate);
    var isEndMinutes = isEndHour && isTypeSame('i', d, endDate);

    if ((isStartMinutes || isEndMinutes) && hasSecond) {
      if (isStartMinutes && isCheckDate !== TIME_PRE_CHECK.USE_END && getDateNum('s', startDate) > getDateNum('s', d)) {
        return RANGE_CHECK_RESULT.BIGGER_THAN_SEC;
      }

      if (isEndMinutes && isCheckDate !== TIME_PRE_CHECK.USE_START && getDateNum('s', endDate) < getDateNum('s', d)) {
        return RANGE_CHECK_RESULT.SMALL_THAN_SEC;
      }
    }
  }

  return RANGE_CHECK_RESULT.IN_RANGE;
}
export function getRangeDate(d, options, validRange) {
  if (!validRange) {
    return d;
  }

  var _validRange2 = _slicedToArray(validRange, 2),
      startDate = _validRange2[0],
      endDate = _validRange2[1];

  var newDate;

  switch (checkDateRange(d, options, validRange)) {
    case RANGE_CHECK_RESULT.IN_RANGE:
      return d;

    case RANGE_CHECK_RESULT.SMALL_THAN_YEAR:
    case RANGE_CHECK_RESULT.SMALL_THAN_MONTH:
    case RANGE_CHECK_RESULT.SMALL_THAN_DAY:
    case RANGE_CHECK_RESULT.SMALL_THAN_HOUR:
    case RANGE_CHECK_RESULT.SMALL_THAN_MIN:
    case RANGE_CHECK_RESULT.SMALL_THAN_SEC:
      newDate = cloneDate(endDate);
      break;

    case RANGE_CHECK_RESULT.BIGGER_THAN_YEAR:
    case RANGE_CHECK_RESULT.BIGGER_THAN_MONTH:
    case RANGE_CHECK_RESULT.BIGGER_THAN_DAY:
    case RANGE_CHECK_RESULT.BIGGER_THAN_HOUR:
    case RANGE_CHECK_RESULT.BIGGER_THAN_MIN:
    case RANGE_CHECK_RESULT.BIGGER_THAN_SEC:
      newDate = cloneDate(startDate);
      break;
  }

  if (options.date) {
    var _options$date2 = options.date,
        hasMonth = _options$date2.hasMonth,
        hasDay = _options$date2.hasDay;

    if (!hasDay) {
      newDate.setDate(1);
    }

    if (!hasMonth) {
      newDate.setMonth(0);

      if (newDate.getMonth() !== 0) {
        newDate.setMonth(0);
      }
    }
  }

  if (options.time) {
    var _options$time2 = options.time,
        hasHour = _options$time2.hasHour,
        hasMinute = _options$time2.hasMinute,
        hasSecond = _options$time2.hasSecond;

    if (!hasHour) {
      newDate.setHours(0);
    }

    if (!hasMinute) {
      newDate.setMinutes(0);
    }

    if (!hasSecond) {
      newDate.setSeconds(0);
    }
  } else {
    newDate.setHours(0, 0, 0);
  }

  newDate.setMilliseconds(0);
  return newDate;
}
var timeTypes = ['Hours', 'Minutes', 'Seconds'];
export function getNearestDate(options, extra, d, calcType) {
  var _options$hasHour = options.hasHour,
      hasHour = _options$hasHour === void 0 ? false : _options$hasHour,
      _options$hasMinute = options.hasMinute,
      hasMinute = _options$hasMinute === void 0 ? false : _options$hasMinute,
      _options$hasSecond = options.hasSecond,
      hasSecond = _options$hasSecond === void 0 ? false : _options$hasSecond;
  var _extra$hourStep = extra.hourStep,
      hourStep = _extra$hourStep === void 0 ? 1 : _extra$hourStep,
      _extra$minuteStep = extra.minuteStep,
      minuteStep = _extra$minuteStep === void 0 ? 1 : _extra$minuteStep,
      _extra$secondStep = extra.secondStep,
      secondStep = _extra$secondStep === void 0 ? 1 : _extra$secondStep;

  var check = function check(has, step, timeType) {
    var setter = Date.prototype["set".concat(timeType)];
    var getter = Date.prototype["get".concat(timeType)];

    if (!has) {
      setter.call(d, 0);
    }

    if (step === 1) {
      return;
    }

    var a = getter.call(d);
    var x = a % step;

    if (x > 0) {
      var type = calcType;

      if (type === 'auto') {
        type = x >= step / 2 ? 'plus' : 'minus';
      }

      if (type === 'plus') {
        setter.call(d, a + (step - x));
      } else {
        setter.call(d, a - x);
      }

      for (var i = timeTypes.indexOf(timeType) + 1; i < timeTypes.length; i++) {
        Date.prototype["set".concat(timeTypes[i])].call(d, 0);
      }
    }
  };

  check(hasSecond, secondStep, 'Seconds');
  check(hasMinute, minuteStep, 'Minutes');
  check(hasHour, hourStep, 'Hours');
  return d;
}
export function getRealRange(options, extra, validRange) {
  if (!validRange) {
    return undefined;
  }

  return [getNearestDate(options, extra, cloneDate(validRange[0]), 'plus'), getNearestDate(options, extra, cloneDate(validRange[1]), 'minus')];
}