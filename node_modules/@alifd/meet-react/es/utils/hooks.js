function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { isNil } from './fp';
export function useValue(props, defaultValue, options) {
  var _ref = options || {},
      _ref$valueName = _ref.valueName,
      valueName = _ref$valueName === void 0 ? 'value' : _ref$valueName,
      fitValue = _ref.fitValue,
      compare = _ref.compare;

  var defaultName = useMemo(function () {
    var n = valueName.substr(0, 1).toUpperCase() + valueName.substr(1);
    return "default".concat(n);
  }, [valueName]);
  var isControlled = (valueName in props);
  var defaultVal = useMemo(function () {
    var v = defaultValue;

    if (defaultName in props) {
      v = props[defaultName];
    }

    if (isControlled) {
      v = props[valueName];
    }

    if (isNil(v)) {
      v = defaultValue;
    }

    if (fitValue) {
      v = fitValue(v);
    }

    return v;
  }, []);

  var getControlledValue = function getControlledValue() {
    var x = props[valueName];

    if (isNil(x)) {
      if (fitValue) {
        return fitValue(defaultValue);
      }

      return defaultValue;
    }

    if (fitValue) {
      return fitValue(x);
    }

    return x;
  };

  var _useState = useState(defaultVal),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var propValue = useRef(defaultVal);
  useEffect(function () {
    if (isControlled) {
      var newValue = getControlledValue();
      var isSame = compare ? compare(newValue, propValue.current) : newValue === propValue.current;

      if (!isSame) {
        propValue.current = newValue;
        setValue(newValue);
      }
    }
  }, [props[valueName], props.dataSource]);

  var setPropValue = function setPropValue(val) {
    var isSame = compare ? compare(val, propValue.current) : val === propValue.current;

    if (!isSame) {
      propValue.current = val;
      setValue(val);
    }
  };

  if (isControlled) {
    return [propValue.current, setValue, isControlled, setPropValue];
  }

  return [value, setValue, isControlled, setPropValue];
}
export function useDeprecated(comp, props, oldName, newName, defaultValue) {
  useEffect(function () {
    if (oldName in props && console && console.warn) {
      console.warn("Warning: ".concat(comp, ".").concat(oldName, " is deprecated and will be removed in a future version, please use ").concat(newName, " instead"));
    }
  }, []);

  if (newName in props) {
    return props[newName];
  }

  if (oldName in props) {
    return props[oldName];
  }

  return defaultValue;
}
var counter = 0;
export function guid() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  counter += 1;
  return "".concat(prefix).concat(counter);
}
export function useGuid() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var id = useRef(guid(prefix));
  return id.current;
}
export function useForceUpdate() {
  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      update = _useState4[1];

  var cb = useCallback(function () {
    return update(function (x) {
      return x >= Number.MAX_SAFE_INTEGER ? 0 : x + 1;
    });
  }, []);
  return cb;
}
export default function useWhyDidYouUpdate(componentName, props) {
  var prevProps = useRef({});
  useEffect(function () {
    if (prevProps.current) {
      var allKeys = Object.keys(Object.assign(Object.assign({}, prevProps.current), props));
      var changedProps = {};
      allKeys.forEach(function (key) {
        if (prevProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: prevProps.current[key],
            to: props[key]
          };
        }
      });

      if (Object.keys(changedProps).length) {
        console.log('[why-did-you-update]', componentName, changedProps);
      }
    }

    prevProps.current = props;
  });
}