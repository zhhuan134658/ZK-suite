import { isUndef, isValidArray } from './fp';
export function find(tree, callback) {
  var found;
  dfs(tree, function (node, par, ctrl) {
    if (callback.call(node, node, par)) {
      ctrl.stop = true;
      found = this;
    }
  });
  return found;
}
export function getSiblings(tree, val) {
  var p;
  dfs(tree, function (node, par) {
    if (node.value === val) {
      p = par;
    }
  });

  if (!p) {
    return tree;
  } else {
    return filter(tree, function (node, par) {
      return par && par.value === p.value;
    });
  }
}
export function filter(tree, callback) {
  var rs = [];
  dfs(tree, function (node, par) {
    if (callback(node, par)) {
      rs.push(node);
    }
  });
  return rs;
}
export function dfs(node, callback) {
  var cur;
  var par;
  var children;
  var ctrl;
  var i;
  var nodes = Array.isArray(node) ? node.slice(0).reverse() : [node];
  var parents = [];
  var childrenName = 'children';

  if (isUndef(nodes[0]) && nodes.length === 1) {
    return;
  }

  for (i = nodes.length - 1; i >= 0; i--) {
    parents.push(undefined);
  }

  while (nodes.length > 0) {
    cur = nodes.pop();
    par = parents.pop();
    ctrl = {};
    callback.call(cur, cur, par, ctrl);

    if (ctrl.stop) {
      break;
    }

    children = cur && cur[childrenName] ? cur[childrenName] : [];

    for (i = ctrl.cutoff ? -1 : children.length - 1; i >= 0; i--) {
      nodes.push(children[i]);
      parents.push(cur);
    }
  }

  return node;
}
export function bfs(node, fn) {}
export function firstChild(tree) {
  var ret = [];

  if (!Array.isArray(tree) || tree.length === 0) {
    return ret;
  }

  var node = tree[0];

  do {
    if (node) {
      ret.push(node);
    }

    node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
  } while (node);

  return ret.map(function (item) {
    return item.value;
  });
}
export function getMaxDepth(tree) {
  var depth = 0;
  tree.forEach(function (item) {
    if (item.children) {
      depth = Math.max(depth, getMaxDepth(item.children) + 1);
    } else {
      depth = Math.max(depth, 1);
    }
  });
  return depth;
}
export function getFirstValue() {
  var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var ret = [];

  if (!Array.isArray(tree) || tree.length === 0) {
    return ret;
  }

  var node = tree[0];

  do {
    if (node) {
      ret.push(node);
    }

    node = Array.isArray(node.children) && node.children.length > 0 ? node.children[0] : null;
  } while (node);

  return ret.map(function (item) {
    return item.value;
  });
}
export function getDataByValues() {
  var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var ret = [];
  var len = values.length;
  var child = tree;

  for (var i = 0; i < len; i++) {
    var val = values[i];
    var l = child.length;
    var flag = false;

    for (var j = 0; j < l; j++) {
      var item = child[j];

      if (item.value === val) {
        flag = true;

        if (Array.isArray(item.children)) {
          child = item.children;
        }

        ret.push(item);
        break;
      }
    }

    if (!flag) {
      ret.push({
        label: val,
        value: val
      });
    }
  }

  return ret;
}
export function getItemsFromDataSource() {
  var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!isUndef(values) && !Array.isArray(values)) {
    values = [values];
  }

  if (!isValidArray(tree) || !isValidArray(values)) {
    return [];
  }

  return values.map(function (val) {
    return find(tree, function (it) {
      return it.value === val;
    }) || {
      lavel: val,
      value: val
    };
  });
}
export function getFullPathByValue(tree, value) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';
  var path = [];
  var nodes = Array.isArray(tree) ? tree : [tree];

  function helper(node) {
    for (var i = 0; i < node.length; i++) {
      var item = node[i];

      if (item[key] === value) {
        path.push(value);
        return true;
      }

      if (item.children && helper(item.children)) {
        path.push(item[key]);
        return true;
      }
    }

    return false;
  }

  helper(nodes);
  return path.reverse();
}