import { isIOS, windowWidth } from '../utils';
var config = {
  trustTags: makeMap('a,abbr,ad,audio,b,blockquote,br,code,col,colgroup,dd,del,dl,dt,div,em,fieldset,h1,h2,h3,h4,h5,h6,hr,i,img,ins,label,legend,li,ol,p,q,ruby,rt,source,span,strong,sub,sup,table,tbody,td,tfoot,th,thead,tr,title,ul,video'),
  blockTags: makeMap('address,article,aside,body,caption,center,cite,footer,header,html,nav,pre,section'),
  ignoreTags: makeMap('area,base,canvas,embed,frame,head,iframe,input,link,map,meta,param,rp,script,source,style,textarea,title,track,wbr'),
  voidTags: makeMap('area,base,br,col,circle,ellipse,embed,frame,hr,img,input,line,link,meta,param,path,polygon,rect,source,track,use,wbr'),
  entities: {
    lt: '<',
    gt: '>',
    quot: '"',
    apos: "'",
    ensp: "\u2002",
    emsp: "\u2003",
    nbsp: '\xA0',
    semi: ';',
    ndash: '–',
    mdash: '—',
    middot: '·',
    lsquo: '‘',
    rsquo: '’',
    ldquo: '“',
    rdquo: '”',
    bull: '•',
    hellip: '…'
  },
  tagStyle: {
    address: 'font-style:italic',
    big: 'display:inline;font-size:1.2em',
    caption: 'display:table-caption;text-align:center',
    center: 'text-align:center',
    cite: 'font-style:italic',
    dd: 'margin-left:40px',
    mark: 'background-color:yellow',
    pre: 'font-family:monospace;white-space:pre',
    s: 'text-decoration:line-through',
    small: 'display:inline;font-size:0.8em',
    strike: 'text-decoration:line-through',
    u: 'text-decoration:underline'
  }
};
var tagSelector = {};
var blankChar = makeMap(' ,\r,\n,\t,\f');
var idIndex = 0;

function makeMap(str) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = list.length; i--;) {
    map[list[i]] = true;
  }

  return map;
}

function decodeEntity(str, amp) {
  var i = str.indexOf('&');

  while (i !== -1) {
    var j = str.indexOf(';', i + 3);
    var code = void 0;

    if (j === -1) {
      break;
    }

    if (str[i + 1] === '#') {
      code = parseInt((str[i + 2] === 'x' ? '0' : '') + str.substring(i + 2, j));

      if (!isNaN(code)) {
        str = str.substr(0, i) + String.fromCharCode(code) + str.substr(j + 1);
      }
    } else {
      code = str.substring(i + 1, j);

      if (config.entities[code] || code === 'amp' && amp) {
        str = str.substr(0, i) + (config.entities[code] || '&') + str.substr(j + 1);
      }
    }

    i = str.indexOf('&', i + 1);
  }

  return str;
}

function HtmlParser(vm) {
  this.options = vm.props || vm.properties || {};
  this.tagStyle = Object.assign({}, config.tagStyle, this.options.tagStyle);
  this.imgList = vm.imgList || [];
  this.plugins = vm.plugins || [];
  this.attrs = Object.create(null);
  this.stack = [];
  this.nodes = [];
  this.pre = (this.options.containerStyle || '').includes('white-space') && this.options.containerStyle.includes('pre') ? 2 : 0;
}

HtmlParser.prototype.parse = function (content) {
  for (var i = this.plugins.length; i--;) {
    if (this.plugins[i].onUpdate) {
      content = this.plugins[i].onUpdate(content, config) || content;
    }
  }

  new Lexer(this).parse(content);

  while (this.stack.length) {
    this.popNode();
  }

  return this.nodes;
};

HtmlParser.prototype.expose = function () {
  for (var i = this.stack.length; i--;) {
    var item = this.stack[i];

    if (item.c || item.name === 'a' || item.name === 'video' || item.name === 'audio') {
      return;
    }

    item.c = 1;
  }
};

HtmlParser.prototype.hook = function (node) {
  for (var i = this.plugins.length; i--;) {
    if (this.plugins[i].onParse && this.plugins[i].onParse(node, this) === false) {
      return false;
    }
  }

  return true;
};

HtmlParser.prototype.getUrl = function (url) {
  var domain = this.options.domain;

  if (url[0] === '/') {
    if (url[1] === '/') {
      url = "".concat(domain ? domain.split('://')[0] : 'http', ":").concat(url);
    } else if (domain) {
      url = domain + url;
    }
  } else if (domain && !url.includes('data:') && !url.includes('://')) {
    url = "".concat(domain, "/").concat(url);
  }

  return url;
};

HtmlParser.prototype.parseStyle = function (node) {
  var attrs = node.attrs;
  var list = (this.tagStyle[node.name] || '').split(';').concat((attrs.style || '').split(';'));
  var styleObj = {};
  var tmp = '';

  if (attrs.id && !this.xml) {
    if (this.options.useAnchor) {
      this.expose();
    } else if (node.name !== 'img' && node.name !== 'a' && node.name !== 'video' && node.name !== 'audio') {
      attrs.id = undefined;
    }
  }

  if (attrs.width) {
    styleObj.width = parseFloat(attrs.width) + (attrs.width.includes('%') ? '%' : 'px');
    attrs.width = undefined;
  }

  if (attrs.height) {
    styleObj.height = parseFloat(attrs.height) + (attrs.height.includes('%') ? '%' : 'px');
    attrs.height = undefined;
  }

  for (var i = 0, len = list.length; i < len; i++) {
    var info = list[i].split(':');

    if (info.length < 2) {
      continue;
    }

    var key = info.shift().trim().toLowerCase();
    var value = info.join(':').trim();

    if (value[0] === '-' && value.lastIndexOf('-') > 0 || value.includes('safe')) {
      tmp += ";".concat(key, ":").concat(value);
    } else if (!styleObj[key] || value.includes('import') || !styleObj[key].includes('import')) {
      if (value.includes('url')) {
        var j = value.indexOf('(') + 1;

        if (j) {
          while (value[j] === '"' || value[j] === "'" || blankChar[value[j]]) {
            j++;
          }

          value = value.substr(0, j) + this.getUrl(value.substr(j));
        }
      } else if (value.includes('rpx')) {
        value = value.replace(/[0-9.]+\s*rpx/g, function ($) {
          return "".concat(parseFloat($) * windowWidth / 750, "px");
        });
      }

      styleObj[key] = value;
    }
  }

  node.attrs.style = tmp;
  return styleObj;
};

HtmlParser.prototype.onTagName = function (name) {
  this.tagName = this.xml ? name : name.toLowerCase();

  if (this.tagName === 'svg') {
    this.xml = (this.xml || 0) + 1;
  }
};

HtmlParser.prototype.onAttrName = function (name) {
  name = this.xml ? name : name.toLowerCase();

  if (name.substr(0, 5) === 'data-') {
    if (name === 'data-src' && !this.attrs.src) {
      this.attrName = 'src';
    } else if (this.tagName === 'img' || this.tagName === 'a') {
      this.attrName = name;
    } else {
      this.attrName = undefined;
    }
  } else {
    this.attrName = name;
    this.attrs[name] = 'T';
  }
};

HtmlParser.prototype.onAttrVal = function (val) {
  var name = this.attrName || '';

  if (name === 'style' || name === 'href') {
    this.attrs[name] = decodeEntity(val, true);
  } else if (name.includes('src')) {
    this.attrs[name] = this.getUrl(decodeEntity(val, true));
  } else if (name) {
    this.attrs[name] = val;
  }
};

HtmlParser.prototype.onOpenTag = function (selfClose) {
  var node = Object.create(null);
  node.name = this.tagName;
  node.attrs = this.attrs;
  this.attrs = Object.create(null);
  var attrs = node.attrs;
  var parent = this.stack[this.stack.length - 1];
  var siblings = parent ? parent.children : this.nodes;
  var close = this.xml ? selfClose : config.voidTags[node.name];

  if (tagSelector[node.name]) {
    attrs["class"] = tagSelector[node.name] + (attrs["class"] ? " ".concat(attrs["class"]) : '');
  }

  if (node.name === 'embed') {
    var src = attrs.src || '';

    if (src.includes('.mp4') || src.includes('.3gp') || src.includes('.m3u8') || (attrs.type || '').includes('video')) {
      node.name = 'video';
    } else if (src.includes('.mp3') || src.includes('.wav') || src.includes('.aac') || src.includes('.m4a') || (attrs.type || '').includes('audio')) {
      node.name = 'audio';
    }

    if (attrs.autostart) {
      attrs.autoplay = 'T';
    }

    attrs.controls = 'T';
  }

  if (node.name === 'video' || node.name === 'audio') {
    if (node.name === 'video' && !attrs.id) {
      attrs.id = "v".concat(idIndex++);
    }

    if (!attrs.controls && !attrs.autoplay) {
      attrs.controls = 'T';
    }

    node.src = [];

    if (attrs.src) {
      node.src.push(attrs.src);
      attrs.src = undefined;
    }

    this.expose();
  }

  if (close) {
    if (!this.hook(node) || config.ignoreTags[node.name]) {
      if (node.name === 'base' && !this.options.domain) {
        this.options.domain = attrs.href;
      } else if (node.name === 'source' && parent && (parent.name === 'video' || parent.name === 'audio') && attrs.src) {
        parent.src.push(attrs.src);
      }

      return;
    }

    var styleObj = this.parseStyle(node);

    if (node.name === 'img') {
      if (attrs.src) {
        if (attrs.src.includes('webp')) {
          node.webp = 'T';
        }

        if (attrs.src.includes('data:') && !attrs['original-src']) {
          attrs.ignore = 'T';
        }

        if (!attrs.ignore || node.webp || attrs.src.includes('cloud://')) {
          for (var i = this.stack.length; i--;) {
            var item = this.stack[i];

            if (item.name === 'a') {
              node.a = item.attrs;
              break;
            }

            var style = item.attrs.style || '';

            if (style.includes('flex:') && !style.includes('flex:0') && !style.includes('flex: 0') && (!styleObj.width || !styleObj.width.includes('%'))) {
              styleObj.width = '100% !important';
              styleObj.height = '';

              for (var j = i + 1; j < this.stack.length; j++) {
                this.stack[j].attrs.style = (this.stack[j].attrs.style || '').replace('inline-', '');
              }
            } else if (style.includes('flex') && styleObj.width === '100%') {
              for (var _j = i + 1; _j < this.stack.length; _j++) {
                var _style = this.stack[_j].attrs.style || '';

                if (!_style.includes(';width') && !_style.includes(' width') && _style.indexOf('width') !== 0) {
                  styleObj.width = '';
                  break;
                }
              }
            } else if (style.includes('inline-block')) {
              if (styleObj.width && styleObj.width[styleObj.width.length - 1] === '%') {
                item.attrs.style += ";max-width:".concat(styleObj.width);
                styleObj.width = '';
              } else {
                item.attrs.style += ';max-width:100%';
              }
            }

            item.c = 1;
          }

          node.i = this.imgList.length;

          var _src = attrs['original-src'] || attrs.src;

          if (this.imgList.includes(_src)) {
            var _i = _src.indexOf('://');

            if (_i !== -1) {
              _i += 3;

              var newSrc = _src.substr(0, _i);

              for (; _i < _src.length; _i++) {
                if (_src[_i] === '/') {
                  break;
                }

                newSrc += Math.random() > 0.5 ? _src[_i].toUpperCase() : _src[_i];
              }

              newSrc += _src.substr(_i);
              _src = newSrc;
            }
          }

          this.imgList.push(_src);
        }
      }

      if (styleObj.display === 'inline') {
        styleObj.display = '';
      }

      if (attrs.ignore) {
        styleObj['max-width'] = styleObj['max-width'] || '100%';
        attrs.style += ';-webkit-touch-callout:none';
      }

      if (parseInt(styleObj.width) > windowWidth) {
        styleObj.height = undefined;
      }

      if (styleObj.width) {
        if (styleObj.width.includes('auto')) {
          styleObj.width = '';
        } else {
          node.w = 'T';

          if (styleObj.height && !styleObj.height.includes('auto')) {
            node.h = 'T';
          }
        }
      }
    } else if (node.name === 'svg') {
      siblings.push(node);
      this.stack.push(node);
      this.popNode();
      return;
    }

    for (var key in styleObj) {
      if (styleObj[key]) {
        attrs.style += ";".concat(key, ":").concat(styleObj[key].replace(' !important', ''));
      }
    }

    attrs.style = attrs.style.substr(1) || undefined;
  } else {
    if ((node.name === 'pre' || (attrs.style || '').includes('white-space') && attrs.style.includes('pre')) && this.pre !== 2) {
      this.pre = 1;
      node.pre = 1;
    }

    node.children = [];
    this.stack.push(node);
  }

  siblings.push(node);
};

HtmlParser.prototype.onCloseTag = function (name) {
  name = this.xml ? name : name.toLowerCase();
  var i;

  for (i = this.stack.length; i--;) {
    if (this.stack[i].name === name) {
      break;
    }
  }

  if (i !== -1) {
    while (this.stack.length > i) {
      this.popNode();
    }
  } else if (name === 'p' || name === 'br') {
    var siblings = this.stack.length ? this.stack[this.stack.length - 1].children : this.nodes;
    siblings.push({
      name: name,
      attrs: {
        "class": tagSelector[name],
        style: this.tagStyle[name]
      }
    });
  }
};

HtmlParser.prototype.popNode = function () {
  var node = this.stack.pop();
  var attrs = node.attrs;
  var children = node.children;
  var parent = this.stack[this.stack.length - 1];
  var siblings = parent ? parent.children : this.nodes;

  if (!this.hook(node) || config.ignoreTags[node.name]) {
    if (node.name === 'title' && children.length && children[0].type === 'text' && this.options.setTitle) {}

    siblings.pop();
    return;
  }

  if (node.pre && this.pre !== 2) {
    node.pre = undefined;
    this.pre = node.pre;

    for (var i = this.stack.length; i--;) {
      if (this.stack[i].pre) {
        this.pre = 1;
      }
    }
  }

  if (node.name === 'svg') {
    if (this.xml > 1) {
      this.xml--;
      return;
    }

    var src = '';
    var _attrs = attrs,
        style = _attrs.style;
    attrs.style = '';

    if (attrs.viewbox) {
      attrs.viewBox = attrs.viewbox;
    }

    attrs.xmlns = 'http://www.w3.org/2000/svg';

    (function traversal(_node) {
      if (_node.type === 'text') {
        src += _node.text;
        return;
      }

      src += "<".concat(_node.name);

      for (var item in _node.attrs) {
        var val = _node.attrs[item];

        if (val) {
          src += " ".concat(item, "=\"").concat(val, "\"");
        }
      }

      if (!_node.children) {
        src += '/>';
      } else {
        src += '>';

        for (var _i2 = 0; _i2 < _node.children.length; _i2++) {
          traversal(_node.children[_i2]);
        }

        src += "</".concat(_node.name, ">");
      }
    })(node);

    node.name = 'img';
    node.attrs = {
      src: "data:image/svg+xml;utf8,".concat(src.replace(/#/g, '%23')),
      style: style,
      ignore: 'T'
    };
    node.children = undefined;
    this.xml = false;
    return;
  }

  var styleObj = {};

  if (attrs.align) {
    if (node.name === 'table') {
      if (attrs.align === 'center') {
        styleObj['margin-inline-end'] = 'auto';
        styleObj['margin-inline-start'] = styleObj['margin-inline-end'];
      } else {
        styleObj["float"] = attrs.align;
      }
    } else {
      styleObj['text-align'] = attrs.align;
    }

    attrs.align = undefined;
  }

  if (node.name === 'font') {
    if (attrs.color) {
      styleObj.color = attrs.color;
      attrs.color = undefined;
    }

    if (attrs.face) {
      styleObj['font-family'] = attrs.face;
      attrs.face = undefined;
    }

    if (attrs.size) {
      var size = parseInt(attrs.size);

      if (!isNaN(size)) {
        if (size < 1) {
          size = 1;
        } else if (size > 7) {
          size = 7;
        }

        styleObj['font-size'] = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'][size - 1];
      }

      attrs.size = undefined;
    }
  }

  if ((attrs["class"] || '').includes('align-center')) {
    styleObj['text-align'] = 'center';
  }

  Object.assign(styleObj, this.parseStyle(node));

  if (node.name !== 'table' && parseInt(styleObj.width) > windowWidth) {
    styleObj['max-width'] = '100%';
    styleObj['box-sizing'] = 'border-box';
  }

  if (config.blockTags[node.name]) {
    node.name = 'div';
  } else if (!config.trustTags[node.name] && !this.xml) {
    node.name = 'span';
  } else if (node.name === 'a' || node.name === 'ad') {
    this.expose();
  } else if (node.name === 'video' || node.name === 'audio') {
    node.children = undefined;
  } else if ((node.name === 'ul' || node.name === 'ol') && node.c) {
    var types = {
      a: 'lower-alpha',
      A: 'upper-alpha',
      i: 'lower-roman',
      I: 'upper-roman'
    };

    if (types[attrs.type]) {
      attrs.style += ";list-style-type:".concat(types[attrs.type]);
      attrs.type = undefined;
    }

    node.c = 1;

    for (var _i3 = children.length; _i3--;) {
      if (children[_i3].name === 'li') {
        children[_i3].c = 1;
      }
    }
  } else if (node.name === 'table') {
    var padding = parseFloat(attrs.cellpadding);
    var spacing = parseFloat(attrs.cellspacing);
    var border = parseFloat(attrs.border);
    node.c = 1;

    if (node.c) {
      if (isNaN(padding)) {
        padding = 2;
      }

      if (isNaN(spacing)) {
        spacing = 2;
      }
    }

    if (border) {
      attrs.style += ";border:".concat(border, "px solid gray");
    }

    if (node.flag && node.c) {
      node.flag = undefined;
      styleObj.display = 'grid';

      if (spacing) {
        styleObj['grid-gap'] = "".concat(spacing, "px");
        styleObj.padding = "".concat(spacing, "px");
      } else if (border) {
        attrs.style += ';border-left:0;border-top:0';
      }

      var width = [];
      var trList = [];
      var cells = [];
      var map = {};

      (function traversal(nodes) {
        for (var _i4 = 0; _i4 < nodes.length; _i4++) {
          if (nodes[_i4].name === 'tr') {
            trList.push(nodes[_i4]);
          } else {
            traversal(nodes[_i4].children || []);
          }
        }
      })(children);

      for (var row = 1; row <= trList.length; row++) {
        var col = 1;

        for (var j = 0; j < trList[row - 1].children.length; j++, col++) {
          var td = trList[row - 1].children[j];

          if (td.name === 'td' || td.name === 'th') {
            while (map["".concat(row, ".").concat(col)]) {
              col++;
            }

            td.c = 1;

            var _style2 = td.attrs.style || '';

            var start = _style2.indexOf('width') ? _style2.indexOf(';width') : 0;

            if (start !== -1) {
              var end = _style2.indexOf(';', start + 6);

              if (end === -1) {
                end = _style2.length;
              }

              if (!td.attrs.colspan) {
                width[col] = _style2.substring(start ? start + 7 : 6, end);
              }

              _style2 = _style2.substr(0, start) + _style2.substr(end);
            }

            _style2 += (border ? ";border:".concat(border, "px solid gray").concat(spacing ? '' : ';border-right:0;border-bottom:0') : '') + (padding ? ";padding:".concat(padding, "px") : '');

            if (td.attrs.colspan) {
              _style2 += ";grid-column-start:".concat(col, ";grid-column-end:").concat(col + parseInt(td.attrs.colspan));

              if (!td.attrs.rowspan) {
                _style2 += ";grid-row-start:".concat(row, ";grid-row-end:").concat(row + 1);
              }

              col += parseInt(td.attrs.colspan) - 1;
            }

            if (td.attrs.rowspan) {
              _style2 += ";grid-row-start:".concat(row, ";grid-row-end:").concat(row + parseInt(td.attrs.rowspan));

              if (!td.attrs.colspan) {
                _style2 += ";grid-column-start:".concat(col, ";grid-column-end:").concat(col + 1);
              }

              for (var rowspan = 1; rowspan < td.attrs.rowspan; rowspan++) {
                for (var colspan = 0; colspan < (td.attrs.colspan || 1); colspan++) {
                  map["".concat(row + rowspan, ".").concat(col - colspan)] = 1;
                }
              }
            }

            if (_style2) {
              td.attrs.style = _style2;
            }

            cells.push(td);
          }
        }

        if (row === 1) {
          var temp = '';

          for (var _i5 = 1; _i5 < col; _i5++) {
            temp += "".concat(width[_i5] ? width[_i5] : 'auto', " ");
          }

          styleObj['grid-template-columns'] = temp;
        }
      }

      node.children = cells;
    } else {
      if (node.c) {
        styleObj.display = 'table';
      }

      if (!isNaN(spacing)) {
        styleObj['border-spacing'] = "".concat(spacing, "px");
      }

      if (border || padding || node.c) {
        (function traversal(nodes) {
          for (var _i6 = 0; _i6 < nodes.length; _i6++) {
            var _td = nodes[_i6];

            if (node.c) {
              _td.c = 1;
            }

            if (_td.name === 'th' || _td.name === 'td') {
              if (border) {
                _td.attrs.style = "border:".concat(border, "px solid gray;").concat(_td.attrs.style || '');
              }

              if (padding) {
                _td.attrs.style = "padding:".concat(padding, "px;").concat(_td.attrs.style || '');
              }
            } else if (_td.children) {
              traversal(_td.children);
            }
          }
        })(children);
      }
    }

    if (this.options.enableTableScroll && !(attrs.style || '').includes('inline')) {
      var table = Object.assign({}, node);
      node.name = 'div';
      node.attrs = {
        style: 'overflow-x:auto;padding:1px'
      };
      node.children = [table];
      attrs = table.attrs;
    }
  } else if ((node.name === 'td' || node.name === 'th') && (attrs.colspan || attrs.rowspan)) {
    for (var _i7 = this.stack.length; _i7--;) {
      if (this.stack[_i7].name === 'table') {
        this.stack[_i7].flag = 1;
        break;
      }
    }
  } else if (node.name === 'ruby') {
    node.name = 'span';

    for (var _i8 = 0; _i8 < children.length - 1; _i8++) {
      if (children[_i8].type === 'text' && children[_i8 + 1].name === 'rt') {
        children[_i8] = {
          name: 'span',
          attrs: {
            style: 'display:inline-block;text-align:center'
          },
          children: [{
            name: 'div',
            attrs: {
              style: "font-size:50%;".concat(children[_i8 + 1].attrs.style || '')
            },
            children: children[_i8 + 1].children
          }, children[_i8]]
        };
        children.splice(_i8 + 1, 1);
      }
    }
  }

  if ((styleObj.display || '').includes('flex') && !node.c) {
    for (var _i9 = children.length; _i9--;) {
      var item = children[_i9];

      if (item.f) {
        item.attrs.style = (item.attrs.style || '') + item.f;
        item.f = undefined;
      }
    }
  }

  var flex = parent && (parent.attrs.style || '').includes('flex') && !node.c && !(styleObj.display || '').includes('inline');

  if (flex) {
    node.f = ';max-width:100%';
  }

  for (var key in styleObj) {
    if (styleObj[key]) {
      var val = ";".concat(key, ":").concat(styleObj[key].replace(' !important', ''));

      if (flex && (key.includes('flex') && key !== 'flex-direction' || key === 'align-self' || styleObj[key][0] === '-' || key === 'width' && val.includes('%'))) {
        node.f += val;

        if (key === 'width') {
          attrs.style += ';width:100%';
        }
      } else {
        attrs.style += val;
      }
    }
  }

  attrs.style = attrs.style.substr(1) || undefined;
};

HtmlParser.prototype.onText = function (text) {
  if (!this.pre) {
    var trim = '';
    var flag;

    for (var i = 0, len = text.length; i < len; i++) {
      if (!blankChar[text[i]]) {
        trim += text[i];
      } else {
        if (trim[trim.length - 1] !== ' ') {
          trim += ' ';
        }

        if (text[i] === '\n' && !flag) {
          flag = true;
        }
      }
    }

    if (trim === ' ' && flag) {
      return;
    }

    text = trim;
  }

  var node = Object.create(null);
  node.type = 'text';
  node.text = decodeEntity(text);

  if (this.hook(node)) {
    if (this.options.selectable === 'force' && isIOS) {
      this.expose();
      node.us = 'T';
    }

    var siblings = this.stack.length ? this.stack[this.stack.length - 1].children : this.nodes;
    siblings.push(node);
  }
};

function Lexer(handler) {
  this.handler = handler;
}

Lexer.prototype.parse = function (content) {
  this.content = content || '';
  this.i = 0;
  this.start = 0;
  this.state = this.text;

  for (var len = this.content.length; this.i !== -1 && this.i < len;) {
    this.state();
  }
};

Lexer.prototype.checkClose = function (method) {
  var selfClose = this.content[this.i] === '/';

  if (this.content[this.i] === '>' || selfClose && this.content[this.i + 1] === '>') {
    if (method) {
      this.handler[method](this.content.substring(this.start, this.i));
    }

    this.i += selfClose ? 2 : 1;
    this.start = this.i;
    this.handler.onOpenTag(selfClose);

    if (this.handler.tagName === 'script') {
      this.i = this.content.indexOf('</', this.i);

      if (this.i !== -1) {
        this.i += 2;
        this.start = this.i;
      }

      this.state = this.endTag;
    } else {
      this.state = this.text;
    }

    return true;
  }

  return false;
};

Lexer.prototype.text = function () {
  this.i = this.content.indexOf('<', this.i);

  if (this.i === -1) {
    if (this.start < this.content.length) {
      this.handler.onText(this.content.substring(this.start, this.content.length));
    }

    return;
  }

  var c = this.content[this.i + 1];

  if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') {
    if (this.start !== this.i) {
      this.handler.onText(this.content.substring(this.start, this.i));
    }

    this.start = ++this.i;
    this.state = this.tagName;
  } else if (c === '/' || c === '!' || c === '?') {
    if (this.start !== this.i) {
      this.handler.onText(this.content.substring(this.start, this.i));
    }

    var next = this.content[this.i + 2];

    if (c === '/' && (next >= 'a' && next <= 'z' || next >= 'A' && next <= 'Z')) {
      this.i += 2;
      this.start = this.i;
      this.state = this.endTag;
      return;
    }

    var end = '-->';

    if (c !== '!' || this.content[this.i + 2] !== '-' || this.content[this.i + 3] !== '-') {
      end = '>';
    }

    this.i = this.content.indexOf(end, this.i);

    if (this.i !== -1) {
      this.i += end.length;
      this.start = this.i;
    }
  } else {
    this.i++;
  }
};

Lexer.prototype.tagName = function () {
  if (blankChar[this.content[this.i]]) {
    this.handler.onTagName(this.content.substring(this.start, this.i));

    while (blankChar[this.content[++this.i]]) {}

    if (this.i < this.content.length && !this.checkClose()) {
      this.start = this.i;
      this.state = this.attrName;
    }
  } else if (!this.checkClose('onTagName')) {
    this.i++;
  }
};

Lexer.prototype.attrName = function () {
  var c = this.content[this.i];

  if (blankChar[c] || c === '=') {
    this.handler.onAttrName(this.content.substring(this.start, this.i));
    var needVal = c === '=';
    var len = this.content.length;

    while (++this.i < len) {
      c = this.content[this.i];

      if (!blankChar[c]) {
        if (this.checkClose()) {
          return;
        }

        if (needVal) {
          this.start = this.i;
          this.state = this.attrVal;
          return;
        }

        if (this.content[this.i] === '=') {
          needVal = true;
        } else {
          this.start = this.i;
          this.state = this.attrName;
          return;
        }
      }
    }
  } else if (!this.checkClose('onAttrName')) {
    this.i++;
  }
};

Lexer.prototype.attrVal = function () {
  var c = this.content[this.i];
  var len = this.content.length;

  if (c === '"' || c === "'") {
    this.start = ++this.i;
    this.i = this.content.indexOf(c, this.i);

    if (this.i === -1) {
      return;
    }

    this.handler.onAttrVal(this.content.substring(this.start, this.i));
  } else {
    for (; this.i < len; this.i++) {
      if (blankChar[this.content[this.i]]) {
        this.handler.onAttrVal(this.content.substring(this.start, this.i));
        break;
      } else if (this.checkClose('onAttrVal')) {
        return;
      }
    }
  }

  while (blankChar[this.content[++this.i]]) {}

  if (this.i < len && !this.checkClose()) {
    this.start = this.i;
    this.state = this.attrName;
  }
};

Lexer.prototype.endTag = function () {
  var c = this.content[this.i];

  if (blankChar[c] || c === '>' || c === '/') {
    this.handler.onCloseTag(this.content.substring(this.start, this.i));

    if (c !== '>') {
      this.i = this.content.indexOf('>', this.i);

      if (this.i === -1) {
        return;
      }
    }

    this.start = ++this.i;
    this.state = this.text;
  } else {
    this.i++;
  }
};

export default HtmlParser;