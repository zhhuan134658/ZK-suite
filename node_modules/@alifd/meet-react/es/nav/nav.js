function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import { __rest } from "tslib";
import classNames from 'classnames';
import React, { createElement, forwardRef, useEffect, useState, Children, cloneElement } from "react";
import { isString, isUndef, isValidArray } from '../utils';
import { dfs } from '../utils/tree';
import View from '../view';
import NavContext from './context';
import Item from './item';
import SubNav from './sub-nav';

var getInitSelectKeys = function getInitSelectKeys(props) {
  var ret = [];

  if ('selectedKeys' in props) {
    if (isValidArray(props.selectedKeys)) {
      ret = props.selectedKeys;
    } else if (isString(props.selectedKeys) && props.selectedKeys) {
      ret = [props.selectedKeys];
    }
  } else if ('defaultSelectedKeys' in props) {
    if (isValidArray(props.defaultSelectedKeys)) {
      ret = props.defaultSelectedKeys;
    } else if (isString(props.defaultSelectedKeys) && props.defaultSelectedKeys) {
      ret = [props.defaultSelectedKeys];
    }
  }

  return isValidArray(ret) ? ret : [];
};

var checkDataSourceKey = function checkDataSourceKey(dataSource) {
  var rs = true;
  dfs(dataSource, function (node) {
    if (rs && !node.key) {
      rs = false;
    }
  });
  return rs;
};

var Nav = function Nav(props, ref) {
  var _props$prefix = props.prefix,
      prefix = _props$prefix === void 0 ? 'mt-' : _props$prefix,
      className = props.className,
      _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      _props$type = props.type,
      type = _props$type === void 0 ? 'normal' : _props$type,
      _props$model = props.model,
      model = _props$model === void 0 ? 'solid' : _props$model,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'ver' : _props$direction,
      defaultSelectedKeys = props.defaultSelectedKeys,
      selectedKeys = props.selectedKeys,
      _props$dataSource = props.dataSource,
      dataSource = _props$dataSource === void 0 ? [] : _props$dataSource,
      children = props.children,
      onSelect = props.onSelect,
      others = __rest(props, ["prefix", "className", "size", "type", "model", "direction", "defaultSelectedKeys", "selectedKeys", "dataSource", "children", "onSelect"]);

  var _useState = useState(getInitSelectKeys(props)),
      _useState2 = _slicedToArray(_useState, 2),
      curSelectedKeys = _useState2[0],
      setCurrentSelectedKeys = _useState2[1];

  var isControlled = ('selectedKeys' in props);
  var clsPrefix = "".concat(prefix, "nav");
  var navClassNames = classNames("".concat(clsPrefix), "".concat(clsPrefix, "--").concat(direction), className);
  var childProps = {
    size: size,
    type: type,
    model: model,
    direction: direction
  };

  var onItemSelect = function onItemSelect(itemKey, e) {
    if (!isControlled) {
      setCurrentSelectedKeys([itemKey]);
    }

    if (onSelect) {
      onSelect(itemKey, e);
    }
  };

  var getRenderNode = function getRenderNode() {
    return dataSource.map(function (item, index) {
      var itemKey = item.key || "".concat(prefix, "nav-").concat(index);
      var icon = item.icon,
          iconUri = item.iconUri,
          _children = item.children;
      return isValidArray(_children) ? /*#__PURE__*/React.createElement(SubNav, {
        key: itemKey,
        itemKey: itemKey,
        icon: icon,
        iconUri: iconUri,
        label: item.label,
        dataSource: _children
      }) : /*#__PURE__*/React.createElement(Item, {
        key: itemKey,
        itemKey: itemKey,
        icon: icon,
        iconUri: iconUri,
        label: item.label
      });
    });
  };

  var getChildrenNode = function getChildrenNode() {
    var _key = 0;
    return Children.map(children, function (child) {
      _key += 1;
      var itemKey = child.key || _key;
      return cloneElement(child, Object.assign(Object.assign({}, childProps), {
        key: "".concat(_key),
        itemKey: "".concat(itemKey),
        size: size
      }));
    });
  };

  useEffect(function () {
    if (isValidArray(dataSource) && !checkDataSourceKey(dataSource)) {
      console.error('each item in dataSource should have key property, plese check');
    }
  }, []);
  useEffect(function () {
    if ('selectedKeys' in props) {
      if (isUndef(props.selectedKeys)) {
        var val = getInitSelectKeys(props);
        setCurrentSelectedKeys(val);
      } else if (isValidArray(props.selectedKeys)) {
        setCurrentSelectedKeys(props.selectedKeys);
      } else if (isString(props.selectedKeys) && props.selectedKeys) {
        setCurrentSelectedKeys([props.selectedKeys]);
      }
    }
  }, [selectedKeys]);
  return /*#__PURE__*/React.createElement(NavContext.Provider, {
    value: {
      curSelectedKeys: curSelectedKeys,
      onItemSelect: onItemSelect,
      model: model,
      direction: direction,
      type: type,
      size: size,
      clsPrefix: clsPrefix
    }
  }, /*#__PURE__*/React.createElement(View, _extends({}, others, {
    ref: ref,
    className: navClassNames
  }), dataSource.length ? getRenderNode() : getChildrenNode()));
};

Nav.displayName = 'Nav';
export default /*#__PURE__*/forwardRef(Nav);