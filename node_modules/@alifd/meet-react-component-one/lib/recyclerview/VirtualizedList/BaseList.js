"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _SizeAndPositionManager = _interopRequireDefault(require("./SizeAndPositionManager"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function (o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var DEFAULT_VIEWPORT = 750;
var STYLE_ITEM = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%'
};
var STYLE_STICKY_ITEM = Object.assign(Object.assign({}, STYLE_ITEM), {
  position: 'sticky'
});
var STYLE_INNER = {
  position: 'relative',
  width: '100%',
  minHeight: '100%'
};
var STYLE_WRAPPER = {
  overflow: 'auto',
  willChange: 'transform',
  WebkitOverflowScrolling: 'touch'
};

var BaseList = /*#__PURE__*/function (_PureComponent) {
  _inherits(BaseList, _PureComponent);

  var _super = _createSuper(BaseList);

  function BaseList() {
    var _this;

    _classCallCheck(this, BaseList);

    _this = _super.apply(this, arguments);
    _this.pixelRatio = 1;
    _this.styleCache = {};
    _this.state = {
      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,
      scrollChangeReason: _constants.SCROLL_CHANGE_REASON.REQUESTED
    };
    _this.pixelRatio = DEFAULT_VIEWPORT / _this.getClientWidth();

    _this.itemSizeGetter = function (itemSize) {
      return function (index) {
        return _this.getSize(index, itemSize);
      };
    };

    _this.sizeAndPositionManager = new _SizeAndPositionManager["default"]({
      itemCount: _this.props.children.length,
      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),
      estimatedItemSize: _this.getEstimatedItemSize()
    });
    _this.scrollDirection = _this.props.horizontal ? _constants.DIRECTION.HORIZONTAL : _constants.DIRECTION.VERTICAL;
    return _this;
  }

  _createClass(BaseList, [{
    key: "getEstimatedItemSize",
    value: function getEstimatedItemSize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;
    }
  }, {
    key: "getSize",
    value: function getSize(index, itemSize) {
      if (typeof itemSize === 'function') {
        return itemSize(index);
      }

      return Array.isArray(itemSize) ? itemSize[index] : itemSize;
    }
  }, {
    key: "getStyle",
    value: function getStyle(index, sticky) {
      var _Object$assign, _Object$assign2;

      var style = this.styleCache[index];

      if (style) {
        return style;
      }

      var _this$sizeAndPosition = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),
          size = _this$sizeAndPosition.size,
          offset = _this$sizeAndPosition.offset;

      return this.styleCache[index] = sticky ? Object.assign(Object.assign({}, STYLE_STICKY_ITEM), (_Object$assign = {}, _defineProperty(_Object$assign, _constants.sizeProp[this.scrollDirection], size), _defineProperty(_Object$assign, _constants.marginProp[this.scrollDirection], offset), _defineProperty(_Object$assign, _constants.oppositeMarginProp[this.scrollDirection], -(offset + size)), _defineProperty(_Object$assign, "zIndex", 1), _Object$assign)) : Object.assign(Object.assign({}, STYLE_ITEM), (_Object$assign2 = {}, _defineProperty(_Object$assign2, _constants.sizeProp[this.scrollDirection], size), _defineProperty(_Object$assign2, _constants.positionProp[this.scrollDirection], offset), _Object$assign2));
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props = this.props,
          estimatedItemSize = _this$props.estimatedItemSize,
          children = _this$props.children,
          itemSize = _this$props.itemSize,
          scrollOffset = _this$props.scrollOffset,
          scrollToAlignment = _this$props.scrollToAlignment,
          scrollToIndex = _this$props.scrollToIndex,
          horizontal = _this$props.horizontal,
          nestedList = _this$props.nestedList,
          active = _this$props.active;
      var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;
      var nestedActiveChanged = nestedList && nextProps.active !== active;
      var itemPropsHaveChanged = nestedActiveChanged || nextProps.children.length !== children.length || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;

      if (nextProps.itemSize !== itemSize) {
        this.sizeAndPositionManager.updateConfig({
          itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)
        });
      }

      this.scrollDirection = horizontal ? _constants.DIRECTION.HORIZONTAL : _constants.DIRECTION.VERTICAL;

      if (nestedActiveChanged || nextProps.children.length !== children.length || nextProps.estimatedItemSize !== estimatedItemSize) {
        this.sizeAndPositionManager.updateConfig({
          itemCount: nextProps.children.length,
          estimatedItemSize: this.getEstimatedItemSize(nextProps)
        });
      }

      if (itemPropsHaveChanged) {
        this.recomputeSizes();
      }

      if (nextProps.scrollOffset !== scrollOffset) {
        this.setState({
          offset: nextProps.scrollOffset || 0,
          scrollChangeReason: _constants.SCROLL_CHANGE_REASON.REQUESTED
        });
      } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {
        this.setState({
          offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.children.length),
          scrollChangeReason: _constants.SCROLL_CHANGE_REASON.REQUESTED
        });
      }
    }
  }, {
    key: "getOffsetForIndex",
    value: function getOffsetForIndex(index) {
      var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;
      var itemCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.children.length;
      var _this$props$style = this.props.style,
          style = _this$props$style === void 0 ? {} : _this$props$style;

      if (index < 0 || index >= itemCount) {
        index = 0;
      }

      return this.sizeAndPositionManager.getUpdatedOffsetForIndex({
        align: scrollToAlignment,
        containerSize: style[_constants.sizeProp[this.scrollDirection]],
        currentOffset: this.state && this.state.offset || 0,
        targetIndex: index
      });
    }
  }, {
    key: "recomputeSizes",
    value: function recomputeSizes() {
      var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.styleCache = {};
      this.sizeAndPositionManager.resetItem(startIndex);
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth() {
      return document.documentElement.clientWidth;
    }
  }, {
    key: "getRenderProps",
    value: function getRenderProps(options) {
      var _this2 = this;

      var _options$style = options.style,
          style = _options$style === void 0 ? {} : _options$style,
          offset = options.offset,
          overscanCount = options.overscanCount,
          totalSize = options.totalSize,
          stickyIndices = options.stickyIndices,
          children = options.children,
          width = options.width;
      var items = [];
      var wrapperStyle = Object.assign(Object.assign(Object.assign({}, STYLE_WRAPPER), style), {
        width: width
      });

      var _this$sizeAndPosition2 = this.sizeAndPositionManager.getVisibleRange({
        containerSize: options[_constants.sizeProp[this.scrollDirection]] || style[_constants.sizeProp[this.scrollDirection]] || 0,
        offset: offset,
        overscanCount: overscanCount
      }),
          start = _this$sizeAndPosition2.start,
          stop = _this$sizeAndPosition2.stop;

      var innerStyle = Object.assign(Object.assign({}, STYLE_INNER), _defineProperty({}, _constants.sizeProp[this.scrollDirection], this.sizeAndPositionManager.getTotalSize(totalSize)));
      var renderChildren = [];

      if (stickyIndices != null && stickyIndices.length !== 0) {
        stickyIndices.forEach(function (index) {
          var child = children[index];
          child.props.style = Object.assign(Object.assign({}, child.props.style), _this2.getStyle(index, true));
          items.push(child);
        });

        if (this.scrollDirection === _constants.DIRECTION.HORIZONTAL) {
          innerStyle.display = 'flex';
        }
      }

      if (typeof start !== 'undefined' && typeof stop !== 'undefined') {
        var index = start;
        renderChildren = children.slice(start, stop + 1);
        renderChildren.forEach(function (child) {
          child.props.style = Object.assign(Object.assign({}, child.props.style), _this2.getStyle(index, false));
          index++;
          items.push(child);
        });
      }

      return {
        wrapperStyle: wrapperStyle,
        innerStyle: innerStyle,
        nodeItems: items
      };
    }
  }]);

  return BaseList;
}(_react.PureComponent);

exports["default"] = BaseList;
BaseList.defaultProps = {
  overscanCount: 3
};
BaseList.propTypes = {
  estimatedItemSize: _propTypes["default"].number,
  itemSize: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].array, _propTypes["default"].func]).isRequired,
  overscanCount: _propTypes["default"].number,
  scrollOffset: _propTypes["default"].number,
  scrollToIndex: _propTypes["default"].number,
  scrollToAlignment: _propTypes["default"].oneOf([_constants.ALIGNMENT.AUTO, _constants.ALIGNMENT.START, _constants.ALIGNMENT.CENTER, _constants.ALIGNMENT.END]),
  horizontal: _propTypes["default"].bool,
  stickyIndices: _propTypes["default"].arrayOf(_propTypes["default"].number),
  style: _propTypes["default"].object,
  width: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].string]),
  totalSize: _propTypes["default"].number
};