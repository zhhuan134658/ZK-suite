"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIconSet = createIconSet;
exports["default"] = void 0;

var _tslib = require("tslib");

var _react = _interopRequireWildcard(require("react"));

var _universalEnv = require("universal-env");

var _text = _interopRequireDefault(require("../text"));

var _image = _interopRequireDefault(require("../image"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var fontCache = new Map();

function createIconSet() {
  var glyphMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fontFamily = arguments.length > 1 ? arguments[1] : undefined;
  var fontFile = arguments.length > 2 ? arguments[2] : undefined;
  var IconFont = /*#__PURE__*/(0, _react.forwardRef)(function (_a, ref) {
    var name = _a.name,
        className = _a.className,
        codePoint = _a.codePoint,
        _a$style = _a.style,
        style = _a$style === void 0 ? {} : _a$style,
        rest = (0, _tslib.__rest)(_a, ["name", "className", "codePoint", "style"]);
    return /*#__PURE__*/_react["default"].createElement(Icon, Object.assign({}, rest, {
      ref: ref,
      className: className,
      style: style,
      source: {
        uri: fontFile,
        codePoint: codePoint || glyphMap[name]
      },
      fontFamily: fontFamily
    }));
  });
  IconFont.displayName = 'IconFont';
  return IconFont;
}

var Icon = /*#__PURE__*/(0, _react.forwardRef)(function (_a, ref) {
  var _a$source = _a.source;
  _a$source = _a$source === void 0 ? {} : _a$source;
  var uri = _a$source.uri,
      codePoint = _a$source.codePoint,
      fontFamily = _a.fontFamily,
      _a$style2 = _a.style,
      style = _a$style2 === void 0 ? {} : _a$style2,
      rest = (0, _tslib.__rest)(_a, ["source", "fontFamily", "style"]);

  if (uri && !codePoint && !fontFamily) {
    return /*#__PURE__*/_react["default"].createElement(_image["default"], Object.assign({}, rest, {
      source: {
        uri: uri
      },
      style: style
    }));
  }

  if (!fontFamily) {
    return /*#__PURE__*/_react["default"].createElement(_text["default"], Object.assign({}, rest, {
      ref: ref,
      style: style
    }), codePoint);
  }

  var fontFile = fontCache.get(fontFamily);

  if (!fontFile) {
    fontCache.set(fontFamily, uri);
    var source = "url('".concat(uri, "')");

    if (_universalEnv.isWeb) {
      if (window.FontFace) {
        var iconfont = new window.FontFace(fontFamily, source);
        document.fonts.add(iconfont);
      } else {
        var iconFontStyles = "@font-face {\n                src: ".concat(source, ";\n                font-family: ").concat(fontFamily, ";\n              }");

        var _style = document.createElement('style');

        _style.type = 'text/css';

        _style.appendChild(document.createTextNode(iconFontStyles));

        document.head.appendChild(_style);
      }
    }
  } else if (fontFile !== uri) {
    console.error("font-family ".concat(fontFamily, " should be unique!"));
    return null;
  }

  return /*#__PURE__*/_react["default"].createElement(_text["default"], Object.assign({}, rest, {
    ref: ref,
    style: Object.assign(Object.assign({}, style), {
      fontFamily: fontFamily
    })
  }), codePoint);
});
Icon.createIconSet = createIconSet;
Icon.displayName = 'Icon';
var _default = Icon;
exports["default"] = _default;