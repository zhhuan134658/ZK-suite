import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { forwardRef, Fragment, useEffect, useImperativeHandle, useRef, useState } from 'react';
import { isMiniApp, isNode, isWeb, isWeChatMiniProgram, isWeex } from 'universal-env';
import './index.css';
import keyboardTypeMap from './keyboardTypeMap';
import setNativeProps from './setNativeProps';
var inputId = 0;

function getText(event) {
  var text = '';

  if (isWeex) {
    text = event.value;
  } else {
    text = event.target.value;
  }

  return text;
}

function genEventObject(event) {
  var text = getText(event);
  return {
    nativeEvent: {
      text: text
    },
    originalEvent: event,
    value: text,
    target: event.target
  };
}

function isControlled(props) {
  return 'value' in props;
}

var TextInput = /*#__PURE__*/forwardRef(function (props, ref) {
  var refEl = useRef(null);
  var styleCls = useRef("one-textinput-placeholder-".concat(inputId++));
  var composition = useRef(false);

  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      forceUpdate = _useState2[1];

  var className = props.className,
      accessibilityLabel = props.accessibilityLabel,
      autoComplete = props.autoComplete,
      editable = props.editable,
      keyboardType = props.keyboardType,
      maxNumberOfLines = props.maxNumberOfLines,
      maxLength = props.maxLength,
      multiline = props.multiline,
      numberOfLines = props.numberOfLines,
      confirmType = props.confirmType,
      randomNumber = props.randomNumber,
      _props$showCount = props.showCount,
      showCount = _props$showCount === void 0 ? true : _props$showCount,
      selectionStart = props.selectionStart,
      selectionEnd = props.selectionEnd,
      _props$composition = props.composition,
      compositionProp = _props$composition === void 0 ? false : _props$composition,
      onCompositionStart = props.onCompositionStart,
      onCompositionEnd = props.onCompositionEnd,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      onChange = props.onChange,
      onChangeText = props.onChangeText,
      _onInput = props.onInput,
      password = props.password,
      secureTextEntry = props.secureTextEntry,
      style = props.style,
      _props$placeholderCol = props.placeholderColor,
      placeholderColor = _props$placeholderCol === void 0 ? '#999999' : _props$placeholderCol,
      value = props.value,
      defaultValue = props.defaultValue,
      _props$controlled = props.controlled,
      controlled = _props$controlled === void 0 ? isControlled(props) : _props$controlled;

  var _useState3 = useState(controlled ? value : defaultValue),
      _useState4 = _slicedToArray(_useState3, 2),
      stateValue = _useState4[0],
      setStateValue = _useState4[1];

  var type = password || secureTextEntry ? 'password' : typeof keyboardTypeMap[keyboardType] === 'undefined' ? keyboardType : keyboardTypeMap[keyboardType];

  if (isMiniApp && !isWeb) {
    var basicSupportTypes = ['text', 'number', 'idcard', 'digit'];

    if (!basicSupportTypes.includes(type) && !my.canIUse("input.type.".concat(type))) {
      type = 'text';
    }
  }

  var setValue = function setValue() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    setNativeProps(refEl.current, {
      value: value
    });
  };

  var triggerChange = function triggerChange(event) {
    if (onChange) onChange(genEventObject(event));
    if (onChangeText) onChangeText(getText(event));
  };

  var handleInput = function handleInput(event) {
    _onInput(genEventObject(event));
  };

  var handleChange = function handleChange(event) {
    setStateValue(getText(event));

    if (composition.current) {
      return;
    }

    triggerChange(event);
  };

  var handleFocus = function handleFocus(event) {
    onFocus(genEventObject(event));
  };

  var handleBlur = function handleBlur(event) {
    onBlur(genEventObject(event));
  };

  var handleCompositionStart = function handleCompositionStart(event) {
    if (compositionProp) {
      composition.current = true;
    }

    if (onCompositionStart) {
      onCompositionStart(genEventObject(event));
    }
  };

  var handleCompositionEnd = function handleCompositionEnd(event) {
    if (compositionProp) {
      composition.current = false;
    }

    if (onCompositionEnd) {
      onCompositionEnd(genEventObject(event));
    }

    if (compositionProp) {
      triggerChange(event);
    }
  };

  var propsCommon = Object.assign(Object.assign({}, props), {
    'aria-label': accessibilityLabel,
    autoComplete: autoComplete && 'on',
    className: ['one-textinput', styleCls.current, className || ''].filter(function (v) {
      return v;
    }).join(' '),
    maxlength: maxLength,
    onChange: (onChange || onChangeText) && handleChange,
    onInput: function onInput(e) {
      _onInput && handleInput(e);

      if (!isWeChatMiniProgram) {
        forceUpdate(function (tick) {
          return tick + 1;
        });
      }
    },
    onBlur: onBlur && handleBlur,
    onFocus: onFocus && handleFocus,
    onCompositionStart: handleCompositionStart,
    onCompositionEnd: handleCompositionEnd,
    ref: refEl
  });
  var disbaled = Boolean(editable !== undefined && !editable);
  var rows = numberOfLines || maxNumberOfLines;
  useImperativeHandle(ref, function () {
    return {
      _nativeNode: refEl.current,
      focus: function focus() {
        refEl.current.focus();
      },
      blur: function blur() {
        refEl.current.blur();
      },
      clear: function clear() {
        setValue('');
      }
    };
  });
  useEffect(function () {
    if (controlled && value !== stateValue && !composition.current) {
      setStateValue(value);
    }
  }, [value]);

  if (multiline) {
    return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement("style", {
      "x-if": (isWeb || isNode) && placeholderColor,
      dangerouslySetInnerHTML: {
        __html: ".".concat(styleCls.current, "::placeholder {\n            color: ").concat(placeholderColor, "\n          }")
      }
    }), /*#__PURE__*/React.createElement("textarea", Object.assign({}, propsCommon, {
      style: Object.assign(Object.assign({}, style), {
        placeholderColor: placeholderColor
      }),
      row: rows,
      rows: rows,
      disabled: disbaled,
      onChange: handleChange,
      value: stateValue,
      "confirm-type": confirmType,
      "show-count": showCount
    }), !isWeex && (stateValue || '')));
  } else {
    return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement("style", {
      "x-if": (isWeb || isNode) && placeholderColor,
      dangerouslySetInnerHTML: {
        __html: ".".concat(styleCls.current, "::placeholder {\n            color: ").concat(placeholderColor, "\n          }")
      }
    }), /*#__PURE__*/React.createElement("input", Object.assign({}, propsCommon, {
      style: Object.assign(Object.assign({}, style), {
        placeholderColor: placeholderColor
      }),
      type: type,
      disabled: disbaled,
      value: stateValue,
      "confirm-type": confirmType,
      "random-Number": randomNumber,
      "selection-start": selectionStart,
      "selection-end": selectionEnd
    })));
  }
});
TextInput.displayName = 'TextInput';
export default TextInput;