import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { PureComponent } from 'react';
import PropTypes from 'prop-types';
import SizeAndPositionManager from './SizeAndPositionManager';
import { ALIGNMENT, DIRECTION, SCROLL_CHANGE_REASON, marginProp, oppositeMarginProp, positionProp, sizeProp } from './constants';
var DEFAULT_VIEWPORT = 750;
var STYLE_ITEM = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%'
};
var STYLE_STICKY_ITEM = Object.assign(Object.assign({}, STYLE_ITEM), {
  position: 'sticky'
});
var STYLE_INNER = {
  position: 'relative',
  width: '100%',
  minHeight: '100%'
};
var STYLE_WRAPPER = {
  overflow: 'auto',
  willChange: 'transform',
  WebkitOverflowScrolling: 'touch'
};

var BaseList = /*#__PURE__*/function (_PureComponent) {
  _inherits(BaseList, _PureComponent);

  var _super = _createSuper(BaseList);

  function BaseList() {
    var _this;

    _classCallCheck(this, BaseList);

    _this = _super.apply(this, arguments);
    _this.pixelRatio = 1;
    _this.styleCache = {};
    _this.state = {
      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,
      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
    };
    _this.pixelRatio = DEFAULT_VIEWPORT / _this.getClientWidth();

    _this.itemSizeGetter = function (itemSize) {
      return function (index) {
        return _this.getSize(index, itemSize);
      };
    };

    _this.sizeAndPositionManager = new SizeAndPositionManager({
      itemCount: _this.props.children.length,
      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),
      estimatedItemSize: _this.getEstimatedItemSize()
    });
    _this.scrollDirection = _this.props.horizontal ? DIRECTION.HORIZONTAL : DIRECTION.VERTICAL;
    return _this;
  }

  _createClass(BaseList, [{
    key: "getEstimatedItemSize",
    value: function getEstimatedItemSize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;
    }
  }, {
    key: "getSize",
    value: function getSize(index, itemSize) {
      if (typeof itemSize === 'function') {
        return itemSize(index);
      }

      return Array.isArray(itemSize) ? itemSize[index] : itemSize;
    }
  }, {
    key: "getStyle",
    value: function getStyle(index, sticky) {
      var _Object$assign, _Object$assign2;

      var style = this.styleCache[index];

      if (style) {
        return style;
      }

      var _this$sizeAndPosition = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),
          size = _this$sizeAndPosition.size,
          offset = _this$sizeAndPosition.offset;

      return this.styleCache[index] = sticky ? Object.assign(Object.assign({}, STYLE_STICKY_ITEM), (_Object$assign = {}, _defineProperty(_Object$assign, sizeProp[this.scrollDirection], size), _defineProperty(_Object$assign, marginProp[this.scrollDirection], offset), _defineProperty(_Object$assign, oppositeMarginProp[this.scrollDirection], -(offset + size)), _defineProperty(_Object$assign, "zIndex", 1), _Object$assign)) : Object.assign(Object.assign({}, STYLE_ITEM), (_Object$assign2 = {}, _defineProperty(_Object$assign2, sizeProp[this.scrollDirection], size), _defineProperty(_Object$assign2, positionProp[this.scrollDirection], offset), _Object$assign2));
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props = this.props,
          estimatedItemSize = _this$props.estimatedItemSize,
          children = _this$props.children,
          itemSize = _this$props.itemSize,
          scrollOffset = _this$props.scrollOffset,
          scrollToAlignment = _this$props.scrollToAlignment,
          scrollToIndex = _this$props.scrollToIndex,
          horizontal = _this$props.horizontal,
          nestedList = _this$props.nestedList,
          active = _this$props.active;
      var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;
      var nestedActiveChanged = nestedList && nextProps.active !== active;
      var itemPropsHaveChanged = nestedActiveChanged || nextProps.children.length !== children.length || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;

      if (nextProps.itemSize !== itemSize) {
        this.sizeAndPositionManager.updateConfig({
          itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)
        });
      }

      this.scrollDirection = horizontal ? DIRECTION.HORIZONTAL : DIRECTION.VERTICAL;

      if (nestedActiveChanged || nextProps.children.length !== children.length || nextProps.estimatedItemSize !== estimatedItemSize) {
        this.sizeAndPositionManager.updateConfig({
          itemCount: nextProps.children.length,
          estimatedItemSize: this.getEstimatedItemSize(nextProps)
        });
      }

      if (itemPropsHaveChanged) {
        this.recomputeSizes();
      }

      if (nextProps.scrollOffset !== scrollOffset) {
        this.setState({
          offset: nextProps.scrollOffset || 0,
          scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
        });
      } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {
        this.setState({
          offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.children.length),
          scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
        });
      }
    }
  }, {
    key: "getOffsetForIndex",
    value: function getOffsetForIndex(index) {
      var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;
      var itemCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.children.length;
      var _this$props$style = this.props.style,
          style = _this$props$style === void 0 ? {} : _this$props$style;

      if (index < 0 || index >= itemCount) {
        index = 0;
      }

      return this.sizeAndPositionManager.getUpdatedOffsetForIndex({
        align: scrollToAlignment,
        containerSize: style[sizeProp[this.scrollDirection]],
        currentOffset: this.state && this.state.offset || 0,
        targetIndex: index
      });
    }
  }, {
    key: "recomputeSizes",
    value: function recomputeSizes() {
      var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.styleCache = {};
      this.sizeAndPositionManager.resetItem(startIndex);
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth() {
      return document.documentElement.clientWidth;
    }
  }, {
    key: "getRenderProps",
    value: function getRenderProps(options) {
      var _this2 = this;

      var _options$style = options.style,
          style = _options$style === void 0 ? {} : _options$style,
          offset = options.offset,
          overscanCount = options.overscanCount,
          totalSize = options.totalSize,
          stickyIndices = options.stickyIndices,
          children = options.children,
          width = options.width;
      var items = [];
      var wrapperStyle = Object.assign(Object.assign(Object.assign({}, STYLE_WRAPPER), style), {
        width: width
      });

      var _this$sizeAndPosition2 = this.sizeAndPositionManager.getVisibleRange({
        containerSize: options[sizeProp[this.scrollDirection]] || style[sizeProp[this.scrollDirection]] || 0,
        offset: offset,
        overscanCount: overscanCount
      }),
          start = _this$sizeAndPosition2.start,
          stop = _this$sizeAndPosition2.stop;

      var innerStyle = Object.assign(Object.assign({}, STYLE_INNER), _defineProperty({}, sizeProp[this.scrollDirection], this.sizeAndPositionManager.getTotalSize(totalSize)));
      var renderChildren = [];

      if (stickyIndices != null && stickyIndices.length !== 0) {
        stickyIndices.forEach(function (index) {
          var child = children[index];
          child.props.style = Object.assign(Object.assign({}, child.props.style), _this2.getStyle(index, true));
          items.push(child);
        });

        if (this.scrollDirection === DIRECTION.HORIZONTAL) {
          innerStyle.display = 'flex';
        }
      }

      if (typeof start !== 'undefined' && typeof stop !== 'undefined') {
        var index = start;
        renderChildren = children.slice(start, stop + 1);
        renderChildren.forEach(function (child) {
          child.props.style = Object.assign(Object.assign({}, child.props.style), _this2.getStyle(index, false));
          index++;
          items.push(child);
        });
      }

      return {
        wrapperStyle: wrapperStyle,
        innerStyle: innerStyle,
        nodeItems: items
      };
    }
  }]);

  return BaseList;
}(PureComponent);

export { BaseList as default };
BaseList.defaultProps = {
  overscanCount: 3
};
BaseList.propTypes = {
  estimatedItemSize: PropTypes.number,
  itemSize: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.func]).isRequired,
  overscanCount: PropTypes.number,
  scrollOffset: PropTypes.number,
  scrollToIndex: PropTypes.number,
  scrollToAlignment: PropTypes.oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),
  horizontal: PropTypes.bool,
  stickyIndices: PropTypes.arrayOf(PropTypes.number),
  style: PropTypes.object,
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  totalSize: PropTypes.number
};