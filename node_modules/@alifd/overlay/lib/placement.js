"use strict";

exports.__esModule = true;
exports["default"] = getPlacements;

var _utils = require("./utils");

;
var placementMap = {
  tl: ['bl', 'tl'],
  t: ['bc', 'tc'],
  tr: ['br', 'tr'],
  lt: ['tr', 'tl'],
  l: ['cr', 'cl'],
  lb: ['br', 'bl'],
  bl: ['tl', 'bl'],
  b: ['tc', 'bc'],
  br: ['tr', 'br'],
  rt: ['tl', 'tr'],
  r: ['cl', 'cr'],
  rb: ['bl', 'br']
};

function getXY(p, staticInfo) {
  var targetInfo = staticInfo.targetInfo,
      containerInfo = staticInfo.containerInfo,
      overlayInfo = staticInfo.overlayInfo,
      opoints = staticInfo.points,
      placementOffset = staticInfo.placementOffset,
      offset = staticInfo.offset,
      rtl = staticInfo.rtl;
  var basex = targetInfo.left - containerInfo.left + containerInfo.scrollLeft;
  var basey = targetInfo.top - containerInfo.top + containerInfo.scrollTop;

  function setPointX(point, positive, width) {
    if (positive === void 0) {
      positive = true;
    }

    var plus = positive ? 1 : -1;

    switch (point) {
      case 'l':
        basex += 0;
        break;

      case 'c':
        basex += plus * width / 2;
        break;

      case 'r':
        basex += plus * width;
        break;
    }
  }

  function setPointY(point, positive, height) {
    if (positive === void 0) {
      positive = true;
    }

    var plus = positive ? 1 : -1;

    switch (point) {
      case 't':
        basey += 0;
        break;

      case 'c':
        basey += plus * height / 2;
        break;

      case 'b':
        basey += plus * height;
        break;
    }
  }

  var points = [].concat(opoints);

  if (p && p in placementMap) {
    points = placementMap[p];
  } // rtl 左右对调


  if (rtl) {
    if (points[0].match(/l/)) {
      points[0] = points[0].replace('l', 'r');
    } else if (points[0].match(/r/)) {
      points[0] = points[0].replace('r', 'l');
    }

    if (points[1].match(/l/)) {
      points[1] = points[1].replace('l', 'r');
    } else if (points[1].match(/r/)) {
      points[1] = points[1].replace('r', 'l');
    }
  } // 目标元素


  setPointY(points[1][0], true, targetInfo.height);
  setPointX(points[1][1], true, targetInfo.width);
  setPointY(points[0][0], false, overlayInfo.height);
  setPointX(points[0][1], false, overlayInfo.width);

  if (placementOffset && p.length >= 1) {
    switch (p[0]) {
      case 't':
        basey -= placementOffset;
        break;

      case 'b':
        basey += placementOffset;
        break;

      case 'l':
        basex -= placementOffset;
        break;

      case 'r':
        basex += placementOffset;
        break;
    }
  }

  return {
    points: points,
    left: basex + offset[0],
    top: basey + offset[1]
  };
}

function shouldResizePlacement(l, t, viewport, staticInfo) {
  var container = staticInfo.container,
      containerInfo = staticInfo.containerInfo,
      overlayInfo = staticInfo.overlayInfo;

  if (viewport !== container) {
    // 说明 container 不具备滚动属性
    var _getViewTopLeft = (0, _utils.getViewTopLeft)(viewport),
        vleft = _getViewTopLeft.left,
        vtop = _getViewTopLeft.top;

    var vwidth = viewport.scrollWidth,
        vheight = viewport.scrollHeight,
        vscrollTop = viewport.scrollTop,
        vscrollLeft = viewport.scrollLeft;
    var nt = t + containerInfo.top - vtop + vscrollTop;
    var nl = l + containerInfo.left - vleft + vscrollLeft;
    return nt < 0 || nl < 0 || nt + overlayInfo.height > vheight || nl + overlayInfo.width > vwidth;
  }

  return t < 0 || l < 0 || t + overlayInfo.height > containerInfo.height || l + overlayInfo.width > containerInfo.width;
}

function getNewPlacement(l, t, p, staticInfo) {
  var overlayInfo = staticInfo.overlayInfo,
      containerInfo = staticInfo.containerInfo;
  var np = p.split('');

  if (np.length === 1) {
    np.push('');
  } // 区域不够


  if (t < 0) {
    // [上边 => 下边, 底部对齐 => 顶部对齐]
    np = [np[0].replace('t', 'b'), np[1].replace('b', 't')];
  } // 区域不够


  if (l < 0) {
    // [左边 => 右边, 右对齐 => 左对齐]
    np = [np[0].replace('l', 'r'), np[1].replace('r', 'l')];
  } // 超出区域


  if (t + overlayInfo.height > containerInfo.height) {
    // [下边 => 上边, 顶部对齐 => 底部对齐]
    np = [np[0].replace('b', 't'), np[1].replace('t', 'b')];
  } // 超出区域


  if (l + overlayInfo.width > containerInfo.width) {
    // [右边 => 左边, 左对齐 => 右对齐]
    np = [np[0].replace('r', 'l'), np[1].replace('l', 'r')];
  }

  return np.join('');
}

function ajustLeftAndTop(l, t, staticInfo) {
  var overlayInfo = staticInfo.overlayInfo,
      containerInfo = staticInfo.containerInfo;

  if (t < 0) {
    t = 0;
  }

  if (l < 0) {
    l = 0;
  }

  if (t + overlayInfo.height > containerInfo.height) {
    t = containerInfo.height - overlayInfo.height;
  }

  if (l + overlayInfo.width > containerInfo.width) {
    l = containerInfo.width - overlayInfo.width;
  }

  return {
    left: l,
    top: t
  };
}
/**
 * 计算相对于 container 的偏移位置
 * @param config 
 * @returns 
 */


function getPlacements(config) {
  var target = config.target,
      overlay = config.overlay,
      container = config.container,
      scrollNode = config.scrollNode,
      oplacement = config.placement,
      _config$placementOffs = config.placementOffset,
      placementOffset = _config$placementOffs === void 0 ? 0 : _config$placementOffs,
      _config$points = config.points,
      opoints = _config$points === void 0 ? ['tl', 'bl'] : _config$points,
      _config$offset = config.offset,
      offset = _config$offset === void 0 ? [0, 0] : _config$offset,
      _config$position = config.position,
      position = _config$position === void 0 ? 'absolute' : _config$position,
      beforePosition = config.beforePosition,
      _config$autoAdjust = config.autoAdjust,
      autoAdjust = _config$autoAdjust === void 0 ? true : _config$autoAdjust,
      _config$autoHideScrol = config.autoHideScrollOverflow,
      autoHideScrollOverflow = _config$autoHideScrol === void 0 ? true : _config$autoHideScrol,
      rtl = config.rtl;
  var placement = oplacement;
  /**
   * 可视窗口是浏览器给用户展示的窗口
   * getBoundingClientRect(): top/left 是相对 viewport 
   * node: offsetTop/offsetarget.Left 是相对 parent 元素的
   * 
   * top: 元素上边  距离可视窗口 上边框的距离
   * left: 元素左边 距离可视窗口 左边框的距离
   * 
   * scrollTop: 容器上下滚动距离
   * scrollLeft: 容器左右滚动距离
   */

  var _getWidthHeight = (0, _utils.getWidthHeight)(overlay),
      owidth = _getWidthHeight.width,
      oheight = _getWidthHeight.height;

  if (position === 'fixed') {
    var _result = {
      config: {
        placement: undefined,
        points: undefined
      },
      style: {
        position: position,
        left: offset[0],
        top: offset[1]
      }
    };

    if (beforePosition && typeof beforePosition) {
      return beforePosition(_result, {
        overlay: {
          node: overlay,
          width: owidth,
          height: oheight
        }
      });
    }

    return _result;
  }

  var _target$getBoundingCl = target.getBoundingClientRect(),
      twidth = _target$getBoundingCl.width,
      theight = _target$getBoundingCl.height,
      tleft = _target$getBoundingCl.left,
      ttop = _target$getBoundingCl.top;

  var _getViewTopLeft2 = (0, _utils.getViewTopLeft)(container),
      cleft = _getViewTopLeft2.left,
      ctop = _getViewTopLeft2.top;

  var cwidth = container.scrollWidth,
      cheight = container.scrollHeight,
      cscrollTop = container.scrollTop,
      cscrollLeft = container.scrollLeft;
  var staticInfo = {
    targetInfo: {
      width: twidth,
      height: theight,
      left: tleft,
      top: ttop
    },
    containerInfo: {
      left: cleft,
      top: ctop,
      width: cwidth,
      height: cheight,
      scrollTop: cscrollTop,
      scrollLeft: cscrollLeft
    },
    overlayInfo: {
      width: owidth,
      height: oheight
    },
    points: opoints,
    placementOffset: placementOffset,
    offset: offset,
    container: container,
    rtl: rtl
  }; // step1: 根据 placement 计算位置

  var _getXY = getXY(placement, staticInfo),
      left = _getXY.left,
      top = _getXY.top,
      points = _getXY.points; // 获取可视区域，来计算容器相对位置


  var viewport = (0, _utils.getViewPort)(container); // step2: 根据 viewport（挂载容器不一定是可视区, eg: 挂载在父节点，但是弹窗超出父节点）重新计算位置. 根据可视区域优化位置
  // 位置动态优化思路见 https://github.com/alibaba-fusion/overlay/issues/2

  if (autoAdjust && placement && shouldResizePlacement(left, top, viewport, staticInfo)) {
    var nplacement = getNewPlacement(left, top, placement, staticInfo); // step2: 空间不够，替换位置重新计算位置

    if (placement !== nplacement) {
      var _getXY2 = getXY(nplacement, staticInfo),
          _nleft = _getXY2.left,
          _ntop = _getXY2.top;

      if (shouldResizePlacement(_nleft, _ntop, viewport, staticInfo)) {
        var nnplacement = getNewPlacement(_nleft, _ntop, nplacement, staticInfo); // step3: 空间依然不够，说明xy轴至少有一个方向是怎么更换位置都不够的。停止计算开始补偿逻辑

        if (nplacement !== nnplacement) {
          var _getXY3 = getXY(nnplacement, staticInfo),
              nnleft = _getXY3.left,
              nntop = _getXY3.top;

          var _ajustLeftAndTop = ajustLeftAndTop(nnleft, nntop, staticInfo),
              nnnleft = _ajustLeftAndTop.left,
              nnntop = _ajustLeftAndTop.top;

          placement = nnplacement;
          left = nnnleft;
          top = nnntop;
        } else {
          placement = nplacement;
          left = _nleft;
          top = _ntop;
        }
      } else {
        placement = nplacement;
        left = _nleft;
        top = _ntop;
      }
    }

    var _ajustLeftAndTop2 = ajustLeftAndTop(left, top, staticInfo),
        nleft = _ajustLeftAndTop2.left,
        ntop = _ajustLeftAndTop2.top;

    left = nleft;
    top = ntop;
  }

  var result = {
    config: {
      placement: placement,
      points: points
    },
    style: {
      position: position,
      left: Math.round(left),
      top: Math.round(top)
    }
  };
  /**
   * step3: 滚动隐藏弹窗逻辑。避免出现 target 已经滚动消失，弹层飘在页面最上方的情况。详细见 https://github.com/alibaba-fusion/overlay/issues/3
   * 触发条件: target 和 document.body 之间存在 overflow 滚动元素， target 进入不可见区域
   */

  if (autoHideScrollOverflow && placement && scrollNode !== null && scrollNode !== void 0 && scrollNode.length) {
    // 滚动改成 transform 提高性能, 但是有动效问题
    // result.style.transform = `translate3d(${result.style.left}px, ${result.style.top}px, 0px)`;
    // result.style.left = 0;
    // result.style.top = 0;
    scrollNode.forEach(function (node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          top = _node$getBoundingClie.top,
          left = _node$getBoundingClie.left,
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      if (ttop + theight < top || ttop > top + height || tleft + twidth < left || tleft > left + width) {
        result.style.display = 'none';
      } else {
        result.style.display = '';
      }
    });
  }

  if (beforePosition && typeof beforePosition) {
    return beforePosition(result, {
      target: {
        node: target,
        width: twidth,
        height: theight,
        left: tleft,
        top: ttop
      },
      overlay: {
        node: overlay,
        width: owidth,
        height: oheight
      }
    });
  }

  return result;
}