import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
var _excluded = ["target", "children", "wrapperClassName", "maskClassName", "maskStyle", "hasMask", "canCloseByMask", "maskRender", "points", "offset", "fixed", "visible", "onRequestClose", "onOpen", "onClose", "container", "placement", "placementOffset", "disableScroll", "canCloseByOutSideClick", "canCloseByEsc", "safeNode", "beforePosition", "onPosition", "cache", "autoAdjust", "autoFocus", "isAnimationEnd", "rtl", "wrapperStyle"],
    _excluded2 = ["setVisibleOverlayToParent"];

var _this = this;

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import React, { useEffect, useState, useCallback, useRef, cloneElement, useContext } from 'react';
import { findDOMNode } from 'react-dom';
import ResizeObserver from 'resize-observer-polyfill';
import { createPortal } from 'react-dom';
import getPlacements from './placement';
import { useListener, getHTMLElement, getTargetNode, getStyle, setStyle, getRelativeContainer, throttle, callRef, getOverflowNodes, getScrollbarWidth, getFocusNodeList } from './utils';
import OverlayContext from './overlay-context';

var isScrollDisplay = function isScrollDisplay(element) {
  try {
    var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');
    return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';
  } catch (e) {// ignore error for firefox
  }

  return true;
};

var hasScroll = function hasScroll(containerNode) {
  var parentNode = containerNode.parentNode;
  return parentNode && parentNode.scrollHeight > parentNode.clientHeight && getScrollbarWidth() > 0 && isScrollDisplay(parentNode) && isScrollDisplay(containerNode);
};
/**
 * 传入的组件可能是没有 forwardRef 包裹的 Functional Component, 会导致取不到 ref
 */


export var RefWrapper = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(RefWrapper, _React$Component);

  function RefWrapper() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = RefWrapper.prototype;

  _proto.render = function render() {
    return this.props.children;
  };

  return RefWrapper;
}(React.Component);
var Overlay = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _overflowRef$current;

  var body = function body() {
    return document.body;
  };

  var target = props.target,
      children = props.children,
      wrapperClassName = props.wrapperClassName,
      maskClassName = props.maskClassName,
      maskStyle = props.maskStyle,
      hasMask = props.hasMask,
      _props$canCloseByMask = props.canCloseByMask,
      canCloseByMask = _props$canCloseByMask === void 0 ? true : _props$canCloseByMask,
      maskRender = props.maskRender,
      points = props.points,
      offset = props.offset,
      fixed = props.fixed,
      visible = props.visible,
      _props$onRequestClose = props.onRequestClose,
      onRequestClose = _props$onRequestClose === void 0 ? function () {} : _props$onRequestClose,
      onOpen = props.onOpen,
      onClose = props.onClose,
      _props$container = props.container,
      popupContainer = _props$container === void 0 ? body : _props$container,
      placement = props.placement,
      placementOffset = props.placementOffset,
      _props$disableScroll = props.disableScroll,
      disableScroll = _props$disableScroll === void 0 ? false : _props$disableScroll,
      _props$canCloseByOutS = props.canCloseByOutSideClick,
      canCloseByOutSideClick = _props$canCloseByOutS === void 0 ? true : _props$canCloseByOutS,
      _props$canCloseByEsc = props.canCloseByEsc,
      canCloseByEsc = _props$canCloseByEsc === void 0 ? true : _props$canCloseByEsc,
      safeNode = props.safeNode,
      beforePosition = props.beforePosition,
      onPosition = props.onPosition,
      _props$cache = props.cache,
      cache = _props$cache === void 0 ? false : _props$cache,
      autoAdjust = props.autoAdjust,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      _props$isAnimationEnd = props.isAnimationEnd,
      isAnimationEnd = _props$isAnimationEnd === void 0 ? true : _props$isAnimationEnd,
      rtl = props.rtl,
      owrapperStyle = props.wrapperStyle,
      others = _objectWithoutPropertiesLoose(props, _excluded);

  var position = fixed ? 'fixed' : 'absolute';

  var _useState = useState(visible),
      firstVisible = _useState[0],
      setFirst = _useState[1];

  var _useState2 = useState(null),
      forceUpdate = _useState2[1];

  var positionStyleRef = useRef({
    position: position
  });
  var getContainer = typeof popupContainer === 'string' ? function () {
    return document.getElementById(popupContainer);
  } : typeof popupContainer !== 'function' ? function () {
    return popupContainer;
  } : popupContainer;

  var _useState3 = useState(null),
      container = _useState3[0],
      setContainer = _useState3[1];

  var targetRef = useRef(null);
  var overlayRef = useRef(null);
  var containerRef = useRef(null);
  var maskRef = useRef(null);
  var overflowRef = useRef([]);
  var lastFocus = useRef(null);
  var ro = useRef(null);

  var _useState4 = useState(Date.now().toString(36)),
      uuid = _useState4[0];

  var _useContext = useContext(OverlayContext),
      setVisibleOverlayToParent = _useContext.setVisibleOverlayToParent,
      otherContext = _objectWithoutPropertiesLoose(_useContext, _excluded2);

  var childIDMap = useRef(new Map());

  var handleOpen = function handleOpen(node) {
    setVisibleOverlayToParent(uuid, node);
    onOpen === null || onOpen === void 0 ? void 0 : onOpen(node);
  };

  var handleClose = function handleClose() {
    setVisibleOverlayToParent(uuid, null);
    onClose === null || onClose === void 0 ? void 0 : onClose();
  };

  var getVisibleOverlayFromChild = function getVisibleOverlayFromChild(id, node) {
    if (node) {
      childIDMap.current.set(id, node);
    } else {
      childIDMap.current["delete"](id);
    } // 让父级也感知


    setVisibleOverlayToParent(id, node);
  };

  var child = React.Children.only(children);

  if (typeof child.ref === 'string') {
    throw new Error('Can not set ref by string in Overlay, use function instead.');
  }

  var updatePosition = function updatePosition() {
    var overlayNode = overlayRef.current;
    var containerNode = containerRef.current;
    var targetNode = targetRef.current;

    if (!overlayNode || !containerNode || !targetNode) {
      return;
    }

    var placements = getPlacements({
      target: targetNode,
      overlay: overlayNode,
      container: containerNode,
      scrollNode: overflowRef.current,
      points: points,
      offset: offset,
      position: position,
      placement: placement,
      placementOffset: placementOffset,
      beforePosition: beforePosition,
      autoAdjust: autoAdjust,
      rtl: rtl
    });
    positionStyleRef.current = placements.style;
    setStyle(overlayNode, placements.style);
    typeof onPosition === 'function' && onPosition(placements);
  }; // 弹窗挂载


  var overlayRefCallback = useCallback(function (nodeRef) {
    var node = findDOMNode(nodeRef);
    overlayRef.current = node;
    callRef(ref, node);

    if (node !== null && container) {
      var containerNode = getRelativeContainer(getHTMLElement(container));
      containerRef.current = containerNode;
      var targetElement = target === 'viewport' ? hasMask ? maskRef.current : body() : getTargetNode(target) || body();
      var targetNode = getHTMLElement(targetElement);
      targetRef.current = targetNode;
      overflowRef.current = getOverflowNodes(targetNode, containerNode); // 1. 这里提前先设置好 position 属性，因为有的节点可能会因为设置了 position 属性导致宽度变小
      // 2. 提前设置 top/left -1000 先把弹窗藏起来，以免影响了 container 的高度计算

      setStyle(node, {
        position: fixed ? 'fixed' : 'absolute',
        top: -1000,
        left: -1000
      });
      var waitTime = 100;
      ro.current = new ResizeObserver(throttle(updatePosition.bind(_this), waitTime));
      ro.current.observe(containerNode);
      ro.current.observe(node);
      forceUpdate({});

      if (autoFocus) {
        // 这里setTimeout是等弹窗位置计算完成再进行 focus，否则弹窗还在页面最低端，会出现突然滚动到页面最下方的情况
        setTimeout(function () {
          var focusableNodes = getFocusNodeList(node);

          if (focusableNodes.length > 0 && focusableNodes[0]) {
            lastFocus.current = document.activeElement;
            focusableNodes[0].focus();
          }
        }, waitTime);
      }

      !cache && handleOpen(node);
    } else {
      !cache && handleClose();

      if (ro.current) {
        ro.current.disconnect();
        ro.current = null;
      }
    }
  }, [container]);

  var clickEvent = function clickEvent(e) {
    // 点击在子元素上面，则忽略。为了兼容 react16，这里用 contains 判断而不利用 e.stopPropagation() 阻止冒泡的特性来处理
    for (var _iterator = _createForOfIteratorHelperLoose(childIDMap.current.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          oNode = _step$value[1];

      var _node2 = getHTMLElement(oNode);

      if (_node2 && (_node2 === e.target || _node2.contains(e.target))) {
        return;
      }
    }

    if (!visible) {
      return;
    } // 点击遮罩关闭


    if (hasMask && maskRef.current === e.target) {
      if (canCloseByMask) {
        onRequestClose('maskClick', e); // TODO: will rename to `mask` in 1.0
      }

      return;
    }

    var safeNodeList = Array.isArray(safeNode) ? safeNode : [safeNode]; // 弹层默认是安全节点

    if (overlayRef.current) {
      safeNodeList.push(function () {
        return overlayRef.current;
      });
    } // 安全节点不关闭


    for (var i = 0; i < safeNodeList.length; i++) {
      var _safeNode = getTargetNode(safeNodeList[i]);

      var _node = getHTMLElement(_safeNode);

      if (_node && (_node === e.target || _node.contains(e.target))) {
        return;
      }
    }

    if (canCloseByOutSideClick) {
      onRequestClose('docClick', e); // TODO: will rename to `doc` in 1.0
    }
  }; // 这里用 mousedown 而不是用 click。因为 click 是 mouseup 才触发。
  // 如果用 click 带来的问题: mousedown 在弹窗内部，然后按住鼠标不放拖动到弹窗外触发 mouseup 结果弹窗关了，这是不期望的展示。 https://github.com/alibaba-fusion/next/issues/742
  // react 17 冒泡问题: 
  //  - react17 中，如果弹窗 mousedown 阻止了 e.stopPropagation(), 那么 document 就不会监听到事件，因为事件冒泡到挂载节点 rootElement 就中断了。
  //  - https://reactjs.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation


  useListener(document, 'mousedown', clickEvent, false, !!(visible && overlayRef.current && (canCloseByOutSideClick || hasMask && canCloseByMask)));

  var keydownEvent = function keydownEvent(e) {
    if (!visible) {
      return;
    } // 无子元素才能 esc 取消关闭


    if (e.keyCode === 27 && canCloseByEsc && !childIDMap.current.size) {
      onRequestClose('esc', e);
    }
  };

  useListener(document, 'keydown', keydownEvent, false, !!(visible && overlayRef.current && canCloseByEsc));

  var scrollEvent = function scrollEvent(e) {
    if (!visible) {
      return;
    }

    updatePosition();
  };

  useListener(overflowRef.current, 'scroll', scrollEvent, false, !!(visible && overlayRef.current && (_overflowRef$current = overflowRef.current) !== null && _overflowRef$current !== void 0 && _overflowRef$current.length)); // 有弹窗情况下在 body 增加 overflow:hidden，两个弹窗同时存在也没问题，会按照堆的方式依次 pop

  useEffect(function () {
    if (visible && disableScroll) {
      var originStyle = document.body.getAttribute('style');
      setStyle(document.body, 'overflow', 'hidden');

      if (hasScroll(document.body)) {
        var scrollWidth = getScrollbarWidth();

        if (scrollWidth) {
          setStyle(document.body, 'padding-right', "calc(" + getStyle(document.body, 'padding-right') + " + " + scrollWidth + "px)");
        }
      }

      return function () {
        document.body.setAttribute('style', originStyle || '');
      };
    }

    return undefined;
  }, [visible && disableScroll]); // 第一次加载并且 visible=false 的情况不挂载弹窗

  useEffect(function () {
    if (!firstVisible && visible) {
      setFirst(true);
    }
  }, [visible]); // cache 情况下的模拟 onOpen/onClose

  var overlayNode = overlayRef.current; // overlayRef.current 可能会异步变化，所以要先接下

  useEffect(function () {
    if (cache && overlayNode) {
      if (visible) {
        updatePosition();
        handleOpen(overlayNode);
      } else {
        handleClose();
      }
    }
  }, [visible, cache && overlayNode]); // autoFocus 弹窗关闭后回到触发点

  useEffect(function () {
    if (!visible && autoFocus && lastFocus.current) {
      lastFocus.current.focus();
      lastFocus.current = null;
    }
  }, [!visible && autoFocus && lastFocus.current]); // container 异步加载, 因为 container 很可能还没渲染完成，所以 visible 后这里异步设置下

  useEffect(function () {
    if (visible) {
      // 首次更新
      if (!container) {
        setContainer(getContainer());
      } else if (getContainer() !== container) {
        setContainer(getContainer());
      }
    }
  }, [visible, popupContainer]);

  if (firstVisible === false || !container) {
    return null;
  }

  if (!visible && !cache && isAnimationEnd) {
    return null;
  }

  var newChildren = child ? /*#__PURE__*/React.createElement(RefWrapper, {
    ref: overlayRefCallback
  }, /*#__PURE__*/cloneElement(child, _extends({}, others, {
    style: _extends({
      top: 0,
      left: 0
    }, child.props.style, positionStyleRef.current)
  }))) : null;

  var wrapperStyle = _extends({}, owrapperStyle);

  if (cache && !visible && isAnimationEnd) {
    wrapperStyle.display = 'none';
  }

  var maskNode = /*#__PURE__*/React.createElement("div", {
    className: maskClassName,
    style: maskStyle,
    ref: maskRef
  });
  var content = /*#__PURE__*/React.createElement("div", {
    className: wrapperClassName,
    style: wrapperStyle
  }, hasMask ? maskRender ? maskRender(maskNode) : maskNode : null, newChildren);
  return /*#__PURE__*/React.createElement(OverlayContext.Provider, {
    value: _extends({}, otherContext, {
      setVisibleOverlayToParent: getVisibleOverlayFromChild
    })
  }, /*#__PURE__*/createPortal(content, container));
});
export default Overlay;