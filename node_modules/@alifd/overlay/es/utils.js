import { useEffect } from 'react';
import { findDOMNode } from 'react-dom';
export function useListener(nodeList, eventName, callback, useCapture, condition) {
  useEffect(function () {
    if (condition) {
      if (!Array.isArray(nodeList)) {
        nodeList = [nodeList];
      }

      nodeList.forEach(function (n) {
        n && n.addEventListener && n.addEventListener(eventName, callback, useCapture || false);
      });
      return function () {
        Array.isArray(nodeList) && nodeList.forEach(function (n) {
          n && n.removeEventListener && n.removeEventListener(eventName, callback, useCapture || false);
        });
      };
    }

    return undefined;
  }, [condition]);
  return;
}
/**
 * 将N个方法合并为一个链式调用的方法
 * @return {Function}     合并后的方法
 *
 * @example
 * func.makeChain(this.handleChange, this.props.onChange);
 */

export function makeChain() {
  var _this = this;

  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  if (fns.length === 1) {
    return fns[0];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    for (var i = 0, j = fns.length; i < j; i++) {
      if (fns[i] && fns[i].apply) {
        //@ts-ignore
        fns[i].apply(_this, args);
      }
    }
  };
}
export function callRef(ref, element) {
  if (!ref) {
    return;
  }

  if (typeof ref === 'string') {
    throw new Error("can not set ref string for " + ref);
  } else if (typeof ref === 'function') {
    ref(element);
  } else if (Object.prototype.hasOwnProperty.call(ref, 'current')) {
    ref.current = element;
  }
}
export function saveRef(ref) {
  if (!ref) {
    return null;
  }

  return function (element) {
    if (typeof ref === 'string') {
      throw new Error("can not set ref string for " + ref);
    } else if (typeof ref === 'function') {
      ref(element);
    } else if (Object.prototype.hasOwnProperty.call(ref, 'current')) {
      ref.current = element;
    }
  };
}
/**
 * 获取 position != static ，用来计算相对位置的容器
 * @param container 
 * @returns 
 */

export var getRelativeContainer = function getRelativeContainer(container) {
  if (typeof document === undefined) {
    return container;
  }

  var calcContainer = container;

  while (getStyle(calcContainer, 'position') === 'static') {
    if (!calcContainer || calcContainer === document.documentElement) {
      return document.documentElement;
    }

    calcContainer = calcContainer.parentNode;
  }

  return calcContainer;
};
/**
 * 获取 target 和 container 之间会滚动的元素 (不包含 target、container)
 * 用来监听滚动元素，自动更新弹窗位置
 * @param targetNode 
 * @param container 
 * @returns 
 */

export var getOverflowNodes = function getOverflowNodes(targetNode, container) {
  if (typeof document === undefined) {
    return [];
  }

  var overflowNodes = [];
  var calcContainer = targetNode;

  while (true) {
    // 忽略 body/documentElement, 不算额外滚动元素
    if (!calcContainer || calcContainer === container || calcContainer === document.body || calcContainer === document.documentElement) {
      break;
    }

    var overflow = getStyle(calcContainer, 'overflow');

    if (overflow && overflow.match(/auto|scroll/)) {
      var _calcContainer = calcContainer,
          clientWidth = _calcContainer.clientWidth,
          clientHeight = _calcContainer.clientHeight,
          scrollWidth = _calcContainer.scrollWidth,
          scrollHeight = _calcContainer.scrollHeight;

      if (clientHeight !== scrollHeight || clientWidth !== scrollWidth) {
        overflowNodes.push(calcContainer);
      }
    }

    calcContainer = calcContainer.parentNode;
  }

  return overflowNodes;
};
/**
 * 获取可视区域，用来计算弹窗应该相对哪个节点做上下左右的位置变化。
 * @param container 
 * @returns 
 */

export function getViewPort(container) {
  var calcContainer = container;

  while (calcContainer) {
    var overflow = getStyle(calcContainer, 'overflow');

    if (overflow !== null && overflow !== void 0 && overflow.match(/auto|scroll|hidden/)) {
      return calcContainer;
    }

    calcContainer = calcContainer.parentNode;
  }

  return document.documentElement;
}
export function getStyle(elt, name) {
  if (!elt || elt.nodeType !== 1) {
    return null;
  }

  var style = window.getComputedStyle(elt, null);
  return style.getPropertyValue(name);
}
var PIXEL_PATTERN = /margin|padding|width|height|max|min|offset|size|top|left/i;
export function setStyle(node, name, value) {
  if (!node) {
    return;
  }

  if (typeof name === 'string') {
    if (typeof value === 'number' && PIXEL_PATTERN.test(name)) {
      value = value + "px";
    } //@ts-ignore


    node.style[name] = value;
  } else if (typeof name === 'object' && arguments.length === 2) {
    //@ts-ignore
    Object.keys(name).forEach(function (key) {
      return setStyle(node, key, name[key]);
    });
  }
} // 默认首次调用是立刻执行

export function throttle(func, wait) {
  var previous = -wait;
  return function () {
    var now = Date.now();
    var args = arguments;

    if (now - previous > wait) {
      //@ts-ignore
      func.apply(this, args);
      previous = now;
    }
  };
}
export function debounce(func, wait) {
  var _arguments = arguments,
      _this2 = this;

  var timeoutID;
  return function () {
    var args = _arguments;
    clearTimeout(timeoutID);
    timeoutID = setTimeout(function () {
      //@ts-ignore
      func.apply(_this2, args);
    }, wait);
  };
}
/**
 * 元素相对于可视区的 left/top
 * @param node 
 * @returns 
 */

export function getViewTopLeft(node) {
  /**
   * document.body 向下滚动后 scrollTop 一直为0，同时 top=-xx 为负数，相当于本身是没有滚动条的，这个逻辑是正确的。
   * document.documentElement 向下滚动后 scrollTop/top 都在变化，会影响计算逻辑，所以这里写死 0
   */
  if (node === document.documentElement) {
    return {
      top: 0,
      left: 0
    };
  }

  var _node$getBoundingClie = node.getBoundingClientRect(),
      left = _node$getBoundingClie.left,
      top = _node$getBoundingClie.top;

  return {
    top: top,
    left: left
  };
}
/**
 * get element size
 * offsetWidth/offsetHeight 更容易获取真实大小，不会受到动画影响优先使用。
 * @param       {Element} element
 * @return      {Object}
 */

export function getWidthHeight(element) {
  // element like `svg` do not have offsetWidth and offsetHeight prop
  // then getBoundingClientRect
  if ('offsetWidth' in element && 'offsetHeight' in element) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  } else {
    var _element$getBoundingC = element.getBoundingClientRect(),
        width = _element$getBoundingC.width,
        height = _element$getBoundingC.height;

    return {
      width: width,
      height: height
    };
  }
}
/**
 * 获取默认的滚动条大小
 * @return {Number} width
 */

export function getScrollbarWidth() {
  var scrollDiv = document.createElement('div');
  scrollDiv.className += 'just-to-get-scrollbar-size';
  setStyle(scrollDiv, {
    position: 'absolute',
    width: '100px',
    height: '100px',
    overflow: 'scroll',
    top: '-9999px'
  });
  document.body && document.body.appendChild(scrollDiv);
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
/**
 * 元素是否可见
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */

function _isVisible(node) {
  while (node) {
    if (node === document.body || node === document.documentElement) {
      break;
    }

    if (node.style.display === 'none' || node.style.visibility === 'hidden') {
      return false;
    }

    node = node.parentNode;
  }

  return true;
}
/**
 * 元素是否可以获取焦点
 * @private
 * @param   {Element}  node
 * @return  {Boolean}
 */


function _isFocusable(node) {
  var nodeName = node.nodeName.toLowerCase();
  var tabIndex = parseInt(node.getAttribute('tabindex'), 10);
  var hasTabIndex = !isNaN(tabIndex) && tabIndex > -1;

  if (_isVisible(node)) {
    if (nodeName === 'input') {
      //@ts-ignore
      return !node.disabled && node.type !== 'hidden';
    } else if (['select', 'textarea', 'button'].indexOf(nodeName) > -1) {
      //@ts-ignore
      return !node.disabled;
    } else if (nodeName === 'a') {
      return node.getAttribute('href') || hasTabIndex;
    } else {
      return hasTabIndex;
    }
  }

  return false;
}
/**
 * 列出能获取焦点的子节点
 * @param  {Element} node 容器节点
 * @return {Array<Element>}
 */


export function getFocusNodeList(node) {
  var res = [];
  var nodeList = node.querySelectorAll('*');
  nodeList.forEach(function (item) {
    if (_isFocusable(item)) {
      var method = item.getAttribute('data-auto-focus') ? 'unshift' : 'push';
      res[method](item);
    }
  });

  if (_isFocusable(node)) {
    res.unshift(node);
  }

  return res;
}
export function getHTMLElement(node) {
  if (node) {
    if (node.nodeType) {
      if (node.nodeType === 1) {
        return node;
      } else {
        return document.body;
      }
    } else if (node === window) {
      return document.body;
    } else {
      return findDOMNode(node);
    }
  }

  return node;
}
export function getTargetNode(target) {
  if (typeof target === 'function') {
    return target();
  } else if (typeof target === 'string') {
    return document.getElementById(target);
  } // 兼容 target = HTMLElement


  return target;
}