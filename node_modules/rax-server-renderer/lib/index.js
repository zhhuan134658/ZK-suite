"use strict";

exports.__esModule = true;
exports.renderToString = renderToString;
exports["default"] = void 0;

var _rax = require("rax");

var _styleUnit = require("style-unit");

var _attribute = require("./attribute");

var _CSSProperty = require("./CSSProperty");

var EMPTY_OBJECT = {};
var VOID_ELEMENTS = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};
var TEXT_SPLIT_COMMENT = '<!--|-->';
var ERROR_COMMENT = '<!--ERROR-->';
var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};
var ESCAPE_REGEXP = /[&><"']/g;
var ESCAPE_TEST_REGEXP = /[&><"']/;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

function escapeText(text) {
  if (!ESCAPE_TEST_REGEXP.test(text)) {
    return text;
  }

  return String(text).replace(ESCAPE_REGEXP, escaper);
}

function merge(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

var DEFAULT_STYLE_OPTIONS = {
  defaultUnit: 'px',
  viewportWidth: 750,
  unitPrecision: 4
};
var UPPERCASE_REGEXP = /[A-Z]/g;
var NUMBER_REGEXP = /^[0-9]*$/;
var CSSPropCache = {};

function styleToCSS(style, options) {
  if (options === void 0) {
    options = {};
  }

  var css = '';

  if (Array.isArray(style)) {
    style = style.reduce(function (prev, curr) {
      return Object.assign(prev, curr);
    }, {});
  } // Use var avoid v8 warns "Unsupported phi use of const or let variable"


  for (var prop in style) {
    var val = style[prop];

    if (val == null) {
      continue;
    } // Handle unit for all numerical property, such as fontWeight: 600 / fontWeight: '600'


    var type = typeof val;

    if (type === 'number' || type === 'string' && NUMBER_REGEXP.test(val)) {
      if (!_CSSProperty.UNITLESS_NUMBER_PROPS[prop]) {
        val = val + options.defaultUnit;
      }
    }

    if (typeof val === 'string' && val.indexOf('rpx') > -1) {
      val = (0, _styleUnit.convertUnit)(val);
    }

    prop = CSSPropCache[prop] ? CSSPropCache[prop] : CSSPropCache[prop] = prop.replace(UPPERCASE_REGEXP, '-$&').toLowerCase();
    css = css + (prop + ":" + val + ";");
  }

  return css;
}

function createMarkupForProperty(prop, value, options) {
  if (prop === 'children') {
    // Ignore children prop
    return '';
  }

  if (prop === 'style') {
    return " style=\"" + styleToCSS(value, options) + "\"";
  }

  if (prop === 'className') {
    return typeof value === 'string' ? " class=\"" + escapeText(value) + "\"" : '';
  }

  if (prop === 'dangerouslySetInnerHTML') {
    // Ignore innerHTML
    return '';
  }

  if ((0, _attribute.shouldRemoveAttribute)(prop, value)) {
    return '';
  }

  var propInfo = (0, _attribute.getPropertyInfo)(prop);
  var propType = propInfo ? propInfo.type : null;
  var valueType = typeof value;

  if (propType === _attribute.BOOLEAN || propType === _attribute.OVERLOADED_BOOLEAN && value === true) {
    return " " + prop;
  }

  if (valueType === 'string') {
    return " " + prop + "=\"" + escapeText(value) + "\"";
  }

  if (valueType === 'number') {
    return " " + prop + "=\"" + String(value) + "\"";
  }

  if (valueType === 'boolean') {
    if (propType === _attribute.BOOLEANISH_STRING || prop.indexOf('data-') === 0 || prop.indexOf('aria-') === 0) {
      return " " + prop + "=\"" + (value ? 'true' : 'false') + "\"";
    }
  }

  return '';
}

;

function propsToString(props, options) {
  var html = '';

  for (var prop in props) {
    var value = props[prop];

    if (prop === 'defaultValue') {
      if (props.value == null) {
        prop = 'value';
      } else {
        continue;
      }
    }

    if (prop === 'defaultChecked') {
      if (!props.checked) {
        prop = 'checked';
      } else {
        continue;
      }
    }

    html = html + createMarkupForProperty(prop, value, options);
  }

  return html;
}

function checkContext(element) {
  // Filter context by `contextTypes` or prevent pass context to child without `contextTypes`,
  // need to distinguish context for passing to child and render, which will cause `Consumer` can not work correctly.
  // The best way to get context is from the nearest parent provider, but it will increase the complexity of SSR.
  if (element.contextTypes || element.childContextTypes) {
    console.error('Warning: ' + 'The legacy "contextTypes" and "childContextTypes" API not working properly in server renderer, ' + 'use the new context API. ' + ("(Current: " + _rax.shared.Host.owner.__getName() + ")"));
  }
}

var updater = {
  setState: function setState(component, partialState, callback) {
    if (partialState) {
      if (!component._pendingState) {
        component._pendingState = partialState;
      } else {
        merge(component._pendingState, partialState);
      }
    }
  },
  forceState: function forceState(component, callback) {// Noop
  }
};
/**
 * Functional Reactive Component Class Wrapper
 */

var ServerReactiveComponent = /*#__PURE__*/function () {
  function ServerReactiveComponent(pureRender, ref) {
    // A pure function
    this._render = pureRender;
    this._hookID = 0;
    this._hooks = {}; // Handles store

    this.didMount = [];
    this.didUpdate = [];
    this.willUnmount = [];

    if (pureRender._forwardRef) {
      this._forwardRef = ref;
    }
  }

  var _proto = ServerReactiveComponent.prototype;

  _proto.getHooks = function getHooks() {
    return this._hooks;
  };

  _proto.getHookID = function getHookID() {
    return ++this._hookID;
  };

  _proto.useContext = function useContext(context) {
    var contextID = context._contextID;

    if (this.context[contextID]) {
      return this.context[contextID].getValue();
    } else {
      return context._defaultValue;
    }
  };

  _proto.render = function render() {
    this._hookID = 0;

    var children = this._render(this.props, this._forwardRef ? this._forwardRef : this.context);

    return children;
  };

  return ServerReactiveComponent;
}();

function createInstance(element, context) {
  var type = element.type;
  var props = element.props || EMPTY_OBJECT;
  var instance; // class component

  if (type.prototype && type.prototype.render) {
    instance = new type(props, context); // eslint-disable-line new-cap

    instance.props = props;
    instance.context = context; // Inject the updater into instance

    instance.updater = updater;

    if (instance.componentWillMount) {
      instance.componentWillMount();

      if (instance._pendingState) {
        var state = instance.state;
        var pending = instance._pendingState;

        if (state == null) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }

        instance._pendingState = null;
      }
    }
  } else {
    var ref = element.ref;
    instance = new ServerReactiveComponent(type, ref);
    instance.props = props;
    instance.context = context;
  }

  return instance;
}

var ServerRenderer = /*#__PURE__*/function () {
  function ServerRenderer(options) {
    this.options = options;
    this.previousWasTextNode = false;
    (0, _styleUnit.setTargetPlatform)('web');
    (0, _styleUnit.setViewportWidth)(options.viewportWidth);
    (0, _styleUnit.setUnitPrecision)(options.unitPrecision);
  }

  var _proto2 = ServerRenderer.prototype;

  _proto2.renderElementToString = function renderElementToString(element, context) {
    if (typeof element === 'string') {
      if (this.previousWasTextNode) {
        return TEXT_SPLIT_COMMENT + escapeText(element);
      }

      this.previousWasTextNode = true;
      return escapeText(element);
    }

    if (element == null || element === false || element === true) {
      this.previousWasTextNode = false;
      return '<!-- _ -->';
    }

    if (typeof element === 'number') {
      if (this.previousWasTextNode) {
        return TEXT_SPLIT_COMMENT + String(element);
      }

      this.previousWasTextNode = true;
      return String(element);
    }

    if (Array.isArray(element)) {
      var html = '';

      for (var index = 0, length = element.length; index < length; index++) {
        var child = element[index];
        html = html + this.renderElementToString(child, context);
      }

      return html;
    } // pre compiled html


    if (element.__html != null) {
      // __html may be empty string
      var _html = element.__html;

      if (element.__isStartWithTextNode && this.previousWasTextNode) {
        _html = TEXT_SPLIT_COMMENT + _html;
      }

      this.previousWasTextNode = element.__isEndWithTextNode ? true : false;
      return _html;
    } // pre compiled attrs


    if (element.__attrs) {
      return propsToString(element.__attrs, this.options);
    }

    var type = element.type;

    if (type) {
      var isClassComponent = type.prototype && type.prototype.render;
      var isFunctionComponent = typeof type === 'function'; // class component || function component

      if (isClassComponent || isFunctionComponent) {
        var instance = createInstance(element, context);
        var currentComponent = {
          // For hooks to get current instance
          _instance: instance
        };

        if (process.env.NODE_ENV !== 'production') {
          var componetName = type.displayName || type.name || element; // Give the component name in render error info (only for development)

          currentComponent.__getName = function () {
            return componetName;
          };
        } // Rax will use owner during rendering, eg: hooks, render error info.


        _rax.shared.Host.owner = currentComponent;

        if (process.env.NODE_ENV !== 'production') {
          checkContext(type);
        }

        var currentContext = instance.context;
        var childContext;

        if (instance.getChildContext) {
          childContext = instance.getChildContext();
        } else if (instance._getChildContext) {
          // Only defined in Provider
          childContext = instance._getChildContext();
        }

        if (childContext) {
          // Why not use Object.assign? for better performance
          currentContext = merge({}, context, childContext);
        }

        var renderedElement = instance.render(); // Reset owner after render, or it will casue memory leak.

        _rax.shared.Host.owner = null;

        if (isClassComponent && instance.componentDidCatch) {
          try {
            return this.renderElementToString(renderedElement, currentContext);
          } catch (e) {
            instance.componentDidCatch(e);
            return ERROR_COMMENT;
          }
        } else {
          return this.renderElementToString(renderedElement, currentContext);
        }
      } else if (typeof type === 'string') {
        // shoud set the identifier to false before render child
        this.previousWasTextNode = false;
        var props = element.props || EMPTY_OBJECT;
        var isVoidElement = VOID_ELEMENTS[type];

        var _html2 = "<" + type + propsToString(props, this.options);

        var innerHTML;

        if (props.dangerouslySetInnerHTML) {
          innerHTML = props.dangerouslySetInnerHTML.__html;
        }

        if (isVoidElement) {
          _html2 = _html2 + '>';
        } else {
          _html2 = _html2 + '>'; // When child is null or undefined, it should be render as <!-- _ -->

          if (props.hasOwnProperty('children')) {
            var children = props.children;

            if (Array.isArray(children)) {
              for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                _html2 = _html2 + this.renderElementToString(child, context);
              }
            } else {
              _html2 = _html2 + this.renderElementToString(children, context);
            }
          } else if (innerHTML != null) {
            // When dangerouslySetInnerHTML is 0, it should be render as 0
            _html2 = _html2 + innerHTML;
          }

          _html2 = _html2 + ("</" + type + ">");
        }

        this.previousWasTextNode = false;
        return _html2;
      } else {
        throwInValidElementError(element);
      }
    } else {
      throwInValidElementError(element);
    }
  };

  return ServerRenderer;
}();

function throwInValidElementError(element) {
  var typeInfo = element === undefined ? '' : '(found: ' + (isPlainObject(element) ? "object with keys {" + Object.keys(element) + "}" : element) + ')';
  console.error("Invalid element type, expected types: Element instance, string, boolean, array, null, undefined. " + typeInfo);
}

function isPlainObject(obj) {
  return EMPTY_OBJECT.toString.call(obj) === '[object Object]';
}

function renderToString(element, options) {
  var serverRenderer = new ServerRenderer(Object.assign({}, DEFAULT_STYLE_OPTIONS, options));
  return serverRenderer.renderElementToString(element, {});
}

var _default = {
  renderToString: renderToString
};
exports["default"] = _default;